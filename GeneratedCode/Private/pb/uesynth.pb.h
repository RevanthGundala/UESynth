#if defined(_MSC_VER)
  #pragma warning (disable:4946) // reinterpret_cast used between related classes: 'class1' and 'class2'
  #pragma warning (disable:4800) // 'type' : forcing value to bool 'true' or 'false' (performance warning)
  #pragma warning (disable:4582) // 'type': constructor is not implicitly called
#endif
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: uesynth.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_uesynth_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_uesynth_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/empty.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_uesynth_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_uesynth_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_uesynth_2eproto;
namespace uesynth {
class ActionRequest;
struct ActionRequestDefaultTypeInternal;
extern ActionRequestDefaultTypeInternal _ActionRequest_default_instance_;
class CaptureRequest;
struct CaptureRequestDefaultTypeInternal;
extern CaptureRequestDefaultTypeInternal _CaptureRequest_default_instance_;
class CommandResponse;
struct CommandResponseDefaultTypeInternal;
extern CommandResponseDefaultTypeInternal _CommandResponse_default_instance_;
class CreateCameraRequest;
struct CreateCameraRequestDefaultTypeInternal;
extern CreateCameraRequestDefaultTypeInternal _CreateCameraRequest_default_instance_;
class DestroyCameraRequest;
struct DestroyCameraRequestDefaultTypeInternal;
extern DestroyCameraRequestDefaultTypeInternal _DestroyCameraRequest_default_instance_;
class DestroyObjectRequest;
struct DestroyObjectRequestDefaultTypeInternal;
extern DestroyObjectRequestDefaultTypeInternal _DestroyObjectRequest_default_instance_;
class FrameResponse;
struct FrameResponseDefaultTypeInternal;
extern FrameResponseDefaultTypeInternal _FrameResponse_default_instance_;
class GetCameraTransformRequest;
struct GetCameraTransformRequestDefaultTypeInternal;
extern GetCameraTransformRequestDefaultTypeInternal _GetCameraTransformRequest_default_instance_;
class GetCameraTransformResponse;
struct GetCameraTransformResponseDefaultTypeInternal;
extern GetCameraTransformResponseDefaultTypeInternal _GetCameraTransformResponse_default_instance_;
class GetObjectTransformRequest;
struct GetObjectTransformRequestDefaultTypeInternal;
extern GetObjectTransformRequestDefaultTypeInternal _GetObjectTransformRequest_default_instance_;
class GetObjectTransformResponse;
struct GetObjectTransformResponseDefaultTypeInternal;
extern GetObjectTransformResponseDefaultTypeInternal _GetObjectTransformResponse_default_instance_;
class ImageResponse;
struct ImageResponseDefaultTypeInternal;
extern ImageResponseDefaultTypeInternal _ImageResponse_default_instance_;
class ListObjectsResponse;
struct ListObjectsResponseDefaultTypeInternal;
extern ListObjectsResponseDefaultTypeInternal _ListObjectsResponse_default_instance_;
class Rotator;
struct RotatorDefaultTypeInternal;
extern RotatorDefaultTypeInternal _Rotator_default_instance_;
class SetCameraTransformRequest;
struct SetCameraTransformRequestDefaultTypeInternal;
extern SetCameraTransformRequestDefaultTypeInternal _SetCameraTransformRequest_default_instance_;
class SetLightingRequest;
struct SetLightingRequestDefaultTypeInternal;
extern SetLightingRequestDefaultTypeInternal _SetLightingRequest_default_instance_;
class SetMaterialRequest;
struct SetMaterialRequestDefaultTypeInternal;
extern SetMaterialRequestDefaultTypeInternal _SetMaterialRequest_default_instance_;
class SetObjectTransformRequest;
struct SetObjectTransformRequestDefaultTypeInternal;
extern SetObjectTransformRequestDefaultTypeInternal _SetObjectTransformRequest_default_instance_;
class SetResolutionRequest;
struct SetResolutionRequestDefaultTypeInternal;
extern SetResolutionRequestDefaultTypeInternal _SetResolutionRequest_default_instance_;
class SpawnObjectRequest;
struct SpawnObjectRequestDefaultTypeInternal;
extern SpawnObjectRequestDefaultTypeInternal _SpawnObjectRequest_default_instance_;
class Transform;
struct TransformDefaultTypeInternal;
extern TransformDefaultTypeInternal _Transform_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
}  // namespace uesynth
PROTOBUF_NAMESPACE_OPEN
template <>
::uesynth::ActionRequest* Arena::CreateMaybeMessage<::uesynth::ActionRequest>(Arena*);
template <>
::uesynth::CaptureRequest* Arena::CreateMaybeMessage<::uesynth::CaptureRequest>(Arena*);
template <>
::uesynth::CommandResponse* Arena::CreateMaybeMessage<::uesynth::CommandResponse>(Arena*);
template <>
::uesynth::CreateCameraRequest* Arena::CreateMaybeMessage<::uesynth::CreateCameraRequest>(Arena*);
template <>
::uesynth::DestroyCameraRequest* Arena::CreateMaybeMessage<::uesynth::DestroyCameraRequest>(Arena*);
template <>
::uesynth::DestroyObjectRequest* Arena::CreateMaybeMessage<::uesynth::DestroyObjectRequest>(Arena*);
template <>
::uesynth::FrameResponse* Arena::CreateMaybeMessage<::uesynth::FrameResponse>(Arena*);
template <>
::uesynth::GetCameraTransformRequest* Arena::CreateMaybeMessage<::uesynth::GetCameraTransformRequest>(Arena*);
template <>
::uesynth::GetCameraTransformResponse* Arena::CreateMaybeMessage<::uesynth::GetCameraTransformResponse>(Arena*);
template <>
::uesynth::GetObjectTransformRequest* Arena::CreateMaybeMessage<::uesynth::GetObjectTransformRequest>(Arena*);
template <>
::uesynth::GetObjectTransformResponse* Arena::CreateMaybeMessage<::uesynth::GetObjectTransformResponse>(Arena*);
template <>
::uesynth::ImageResponse* Arena::CreateMaybeMessage<::uesynth::ImageResponse>(Arena*);
template <>
::uesynth::ListObjectsResponse* Arena::CreateMaybeMessage<::uesynth::ListObjectsResponse>(Arena*);
template <>
::uesynth::Rotator* Arena::CreateMaybeMessage<::uesynth::Rotator>(Arena*);
template <>
::uesynth::SetCameraTransformRequest* Arena::CreateMaybeMessage<::uesynth::SetCameraTransformRequest>(Arena*);
template <>
::uesynth::SetLightingRequest* Arena::CreateMaybeMessage<::uesynth::SetLightingRequest>(Arena*);
template <>
::uesynth::SetMaterialRequest* Arena::CreateMaybeMessage<::uesynth::SetMaterialRequest>(Arena*);
template <>
::uesynth::SetObjectTransformRequest* Arena::CreateMaybeMessage<::uesynth::SetObjectTransformRequest>(Arena*);
template <>
::uesynth::SetResolutionRequest* Arena::CreateMaybeMessage<::uesynth::SetResolutionRequest>(Arena*);
template <>
::uesynth::SpawnObjectRequest* Arena::CreateMaybeMessage<::uesynth::SpawnObjectRequest>(Arena*);
template <>
::uesynth::Transform* Arena::CreateMaybeMessage<::uesynth::Transform>(Arena*);
template <>
::uesynth::Vector3* Arena::CreateMaybeMessage<::uesynth::Vector3>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace uesynth {

// ===================================================================


// -------------------------------------------------------------------

class ActionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.ActionRequest) */ {
 public:
  inline ActionRequest() : ActionRequest(nullptr) {}
  ~ActionRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ActionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionRequest(const ActionRequest& from);
  ActionRequest(ActionRequest&& from) noexcept
    : ActionRequest() {
    *this = ::std::move(from);
  }

  inline ActionRequest& operator=(const ActionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionRequest& operator=(ActionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionRequest& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kSetCameraTransform = 2,
    kGetCameraTransform = 3,
    kCaptureRgb = 4,
    kCaptureDepth = 5,
    kCaptureSegmentation = 6,
    kCaptureNormals = 7,
    kCaptureOpticalFlow = 8,
    kSetObjectTransform = 9,
    kGetObjectTransform = 10,
    kCreateCamera = 11,
    kDestroyCamera = 12,
    kSetResolution = 13,
    kSpawnObject = 14,
    kDestroyObject = 15,
    kSetMaterial = 16,
    kListObjects = 17,
    kSetLighting = 18,
    ACTION_NOT_SET = 0,
  };

  static inline const ActionRequest* internal_default_instance() {
    return reinterpret_cast<const ActionRequest*>(
               &_ActionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ActionRequest& a, ActionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionRequest& from) {
    ActionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.ActionRequest";
  }
  protected:
  explicit ActionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kSetCameraTransformFieldNumber = 2,
    kGetCameraTransformFieldNumber = 3,
    kCaptureRgbFieldNumber = 4,
    kCaptureDepthFieldNumber = 5,
    kCaptureSegmentationFieldNumber = 6,
    kCaptureNormalsFieldNumber = 7,
    kCaptureOpticalFlowFieldNumber = 8,
    kSetObjectTransformFieldNumber = 9,
    kGetObjectTransformFieldNumber = 10,
    kCreateCameraFieldNumber = 11,
    kDestroyCameraFieldNumber = 12,
    kSetResolutionFieldNumber = 13,
    kSpawnObjectFieldNumber = 14,
    kDestroyObjectFieldNumber = 15,
    kSetMaterialFieldNumber = 16,
    kListObjectsFieldNumber = 17,
    kSetLightingFieldNumber = 18,
  };
  // string request_id = 1;
  void clear_request_id() ;
  const std::string& request_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_request_id(Arg_&& arg, Args_... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* ptr);

  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(
      const std::string& value);
  std::string* _internal_mutable_request_id();

  public:
  // .uesynth.SetCameraTransformRequest set_camera_transform = 2;
  bool has_set_camera_transform() const;
  private:
  bool _internal_has_set_camera_transform() const;

  public:
  void clear_set_camera_transform() ;
  const ::uesynth::SetCameraTransformRequest& set_camera_transform() const;
  PROTOBUF_NODISCARD ::uesynth::SetCameraTransformRequest* release_set_camera_transform();
  ::uesynth::SetCameraTransformRequest* mutable_set_camera_transform();
  void set_allocated_set_camera_transform(::uesynth::SetCameraTransformRequest* set_camera_transform);
  private:
  const ::uesynth::SetCameraTransformRequest& _internal_set_camera_transform() const;
  ::uesynth::SetCameraTransformRequest* _internal_mutable_set_camera_transform();
  public:
  void unsafe_arena_set_allocated_set_camera_transform(
      ::uesynth::SetCameraTransformRequest* set_camera_transform);
  ::uesynth::SetCameraTransformRequest* unsafe_arena_release_set_camera_transform();
  // .uesynth.GetCameraTransformRequest get_camera_transform = 3;
  bool has_get_camera_transform() const;
  private:
  bool _internal_has_get_camera_transform() const;

  public:
  void clear_get_camera_transform() ;
  const ::uesynth::GetCameraTransformRequest& get_camera_transform() const;
  PROTOBUF_NODISCARD ::uesynth::GetCameraTransformRequest* release_get_camera_transform();
  ::uesynth::GetCameraTransformRequest* mutable_get_camera_transform();
  void set_allocated_get_camera_transform(::uesynth::GetCameraTransformRequest* get_camera_transform);
  private:
  const ::uesynth::GetCameraTransformRequest& _internal_get_camera_transform() const;
  ::uesynth::GetCameraTransformRequest* _internal_mutable_get_camera_transform();
  public:
  void unsafe_arena_set_allocated_get_camera_transform(
      ::uesynth::GetCameraTransformRequest* get_camera_transform);
  ::uesynth::GetCameraTransformRequest* unsafe_arena_release_get_camera_transform();
  // .uesynth.CaptureRequest capture_rgb = 4;
  bool has_capture_rgb() const;
  private:
  bool _internal_has_capture_rgb() const;

  public:
  void clear_capture_rgb() ;
  const ::uesynth::CaptureRequest& capture_rgb() const;
  PROTOBUF_NODISCARD ::uesynth::CaptureRequest* release_capture_rgb();
  ::uesynth::CaptureRequest* mutable_capture_rgb();
  void set_allocated_capture_rgb(::uesynth::CaptureRequest* capture_rgb);
  private:
  const ::uesynth::CaptureRequest& _internal_capture_rgb() const;
  ::uesynth::CaptureRequest* _internal_mutable_capture_rgb();
  public:
  void unsafe_arena_set_allocated_capture_rgb(
      ::uesynth::CaptureRequest* capture_rgb);
  ::uesynth::CaptureRequest* unsafe_arena_release_capture_rgb();
  // .uesynth.CaptureRequest capture_depth = 5;
  bool has_capture_depth() const;
  private:
  bool _internal_has_capture_depth() const;

  public:
  void clear_capture_depth() ;
  const ::uesynth::CaptureRequest& capture_depth() const;
  PROTOBUF_NODISCARD ::uesynth::CaptureRequest* release_capture_depth();
  ::uesynth::CaptureRequest* mutable_capture_depth();
  void set_allocated_capture_depth(::uesynth::CaptureRequest* capture_depth);
  private:
  const ::uesynth::CaptureRequest& _internal_capture_depth() const;
  ::uesynth::CaptureRequest* _internal_mutable_capture_depth();
  public:
  void unsafe_arena_set_allocated_capture_depth(
      ::uesynth::CaptureRequest* capture_depth);
  ::uesynth::CaptureRequest* unsafe_arena_release_capture_depth();
  // .uesynth.CaptureRequest capture_segmentation = 6;
  bool has_capture_segmentation() const;
  private:
  bool _internal_has_capture_segmentation() const;

  public:
  void clear_capture_segmentation() ;
  const ::uesynth::CaptureRequest& capture_segmentation() const;
  PROTOBUF_NODISCARD ::uesynth::CaptureRequest* release_capture_segmentation();
  ::uesynth::CaptureRequest* mutable_capture_segmentation();
  void set_allocated_capture_segmentation(::uesynth::CaptureRequest* capture_segmentation);
  private:
  const ::uesynth::CaptureRequest& _internal_capture_segmentation() const;
  ::uesynth::CaptureRequest* _internal_mutable_capture_segmentation();
  public:
  void unsafe_arena_set_allocated_capture_segmentation(
      ::uesynth::CaptureRequest* capture_segmentation);
  ::uesynth::CaptureRequest* unsafe_arena_release_capture_segmentation();
  // .uesynth.CaptureRequest capture_normals = 7;
  bool has_capture_normals() const;
  private:
  bool _internal_has_capture_normals() const;

  public:
  void clear_capture_normals() ;
  const ::uesynth::CaptureRequest& capture_normals() const;
  PROTOBUF_NODISCARD ::uesynth::CaptureRequest* release_capture_normals();
  ::uesynth::CaptureRequest* mutable_capture_normals();
  void set_allocated_capture_normals(::uesynth::CaptureRequest* capture_normals);
  private:
  const ::uesynth::CaptureRequest& _internal_capture_normals() const;
  ::uesynth::CaptureRequest* _internal_mutable_capture_normals();
  public:
  void unsafe_arena_set_allocated_capture_normals(
      ::uesynth::CaptureRequest* capture_normals);
  ::uesynth::CaptureRequest* unsafe_arena_release_capture_normals();
  // .uesynth.CaptureRequest capture_optical_flow = 8;
  bool has_capture_optical_flow() const;
  private:
  bool _internal_has_capture_optical_flow() const;

  public:
  void clear_capture_optical_flow() ;
  const ::uesynth::CaptureRequest& capture_optical_flow() const;
  PROTOBUF_NODISCARD ::uesynth::CaptureRequest* release_capture_optical_flow();
  ::uesynth::CaptureRequest* mutable_capture_optical_flow();
  void set_allocated_capture_optical_flow(::uesynth::CaptureRequest* capture_optical_flow);
  private:
  const ::uesynth::CaptureRequest& _internal_capture_optical_flow() const;
  ::uesynth::CaptureRequest* _internal_mutable_capture_optical_flow();
  public:
  void unsafe_arena_set_allocated_capture_optical_flow(
      ::uesynth::CaptureRequest* capture_optical_flow);
  ::uesynth::CaptureRequest* unsafe_arena_release_capture_optical_flow();
  // .uesynth.SetObjectTransformRequest set_object_transform = 9;
  bool has_set_object_transform() const;
  private:
  bool _internal_has_set_object_transform() const;

  public:
  void clear_set_object_transform() ;
  const ::uesynth::SetObjectTransformRequest& set_object_transform() const;
  PROTOBUF_NODISCARD ::uesynth::SetObjectTransformRequest* release_set_object_transform();
  ::uesynth::SetObjectTransformRequest* mutable_set_object_transform();
  void set_allocated_set_object_transform(::uesynth::SetObjectTransformRequest* set_object_transform);
  private:
  const ::uesynth::SetObjectTransformRequest& _internal_set_object_transform() const;
  ::uesynth::SetObjectTransformRequest* _internal_mutable_set_object_transform();
  public:
  void unsafe_arena_set_allocated_set_object_transform(
      ::uesynth::SetObjectTransformRequest* set_object_transform);
  ::uesynth::SetObjectTransformRequest* unsafe_arena_release_set_object_transform();
  // .uesynth.GetObjectTransformRequest get_object_transform = 10;
  bool has_get_object_transform() const;
  private:
  bool _internal_has_get_object_transform() const;

  public:
  void clear_get_object_transform() ;
  const ::uesynth::GetObjectTransformRequest& get_object_transform() const;
  PROTOBUF_NODISCARD ::uesynth::GetObjectTransformRequest* release_get_object_transform();
  ::uesynth::GetObjectTransformRequest* mutable_get_object_transform();
  void set_allocated_get_object_transform(::uesynth::GetObjectTransformRequest* get_object_transform);
  private:
  const ::uesynth::GetObjectTransformRequest& _internal_get_object_transform() const;
  ::uesynth::GetObjectTransformRequest* _internal_mutable_get_object_transform();
  public:
  void unsafe_arena_set_allocated_get_object_transform(
      ::uesynth::GetObjectTransformRequest* get_object_transform);
  ::uesynth::GetObjectTransformRequest* unsafe_arena_release_get_object_transform();
  // .uesynth.CreateCameraRequest create_camera = 11;
  bool has_create_camera() const;
  private:
  bool _internal_has_create_camera() const;

  public:
  void clear_create_camera() ;
  const ::uesynth::CreateCameraRequest& create_camera() const;
  PROTOBUF_NODISCARD ::uesynth::CreateCameraRequest* release_create_camera();
  ::uesynth::CreateCameraRequest* mutable_create_camera();
  void set_allocated_create_camera(::uesynth::CreateCameraRequest* create_camera);
  private:
  const ::uesynth::CreateCameraRequest& _internal_create_camera() const;
  ::uesynth::CreateCameraRequest* _internal_mutable_create_camera();
  public:
  void unsafe_arena_set_allocated_create_camera(
      ::uesynth::CreateCameraRequest* create_camera);
  ::uesynth::CreateCameraRequest* unsafe_arena_release_create_camera();
  // .uesynth.DestroyCameraRequest destroy_camera = 12;
  bool has_destroy_camera() const;
  private:
  bool _internal_has_destroy_camera() const;

  public:
  void clear_destroy_camera() ;
  const ::uesynth::DestroyCameraRequest& destroy_camera() const;
  PROTOBUF_NODISCARD ::uesynth::DestroyCameraRequest* release_destroy_camera();
  ::uesynth::DestroyCameraRequest* mutable_destroy_camera();
  void set_allocated_destroy_camera(::uesynth::DestroyCameraRequest* destroy_camera);
  private:
  const ::uesynth::DestroyCameraRequest& _internal_destroy_camera() const;
  ::uesynth::DestroyCameraRequest* _internal_mutable_destroy_camera();
  public:
  void unsafe_arena_set_allocated_destroy_camera(
      ::uesynth::DestroyCameraRequest* destroy_camera);
  ::uesynth::DestroyCameraRequest* unsafe_arena_release_destroy_camera();
  // .uesynth.SetResolutionRequest set_resolution = 13;
  bool has_set_resolution() const;
  private:
  bool _internal_has_set_resolution() const;

  public:
  void clear_set_resolution() ;
  const ::uesynth::SetResolutionRequest& set_resolution() const;
  PROTOBUF_NODISCARD ::uesynth::SetResolutionRequest* release_set_resolution();
  ::uesynth::SetResolutionRequest* mutable_set_resolution();
  void set_allocated_set_resolution(::uesynth::SetResolutionRequest* set_resolution);
  private:
  const ::uesynth::SetResolutionRequest& _internal_set_resolution() const;
  ::uesynth::SetResolutionRequest* _internal_mutable_set_resolution();
  public:
  void unsafe_arena_set_allocated_set_resolution(
      ::uesynth::SetResolutionRequest* set_resolution);
  ::uesynth::SetResolutionRequest* unsafe_arena_release_set_resolution();
  // .uesynth.SpawnObjectRequest spawn_object = 14;
  bool has_spawn_object() const;
  private:
  bool _internal_has_spawn_object() const;

  public:
  void clear_spawn_object() ;
  const ::uesynth::SpawnObjectRequest& spawn_object() const;
  PROTOBUF_NODISCARD ::uesynth::SpawnObjectRequest* release_spawn_object();
  ::uesynth::SpawnObjectRequest* mutable_spawn_object();
  void set_allocated_spawn_object(::uesynth::SpawnObjectRequest* spawn_object);
  private:
  const ::uesynth::SpawnObjectRequest& _internal_spawn_object() const;
  ::uesynth::SpawnObjectRequest* _internal_mutable_spawn_object();
  public:
  void unsafe_arena_set_allocated_spawn_object(
      ::uesynth::SpawnObjectRequest* spawn_object);
  ::uesynth::SpawnObjectRequest* unsafe_arena_release_spawn_object();
  // .uesynth.DestroyObjectRequest destroy_object = 15;
  bool has_destroy_object() const;
  private:
  bool _internal_has_destroy_object() const;

  public:
  void clear_destroy_object() ;
  const ::uesynth::DestroyObjectRequest& destroy_object() const;
  PROTOBUF_NODISCARD ::uesynth::DestroyObjectRequest* release_destroy_object();
  ::uesynth::DestroyObjectRequest* mutable_destroy_object();
  void set_allocated_destroy_object(::uesynth::DestroyObjectRequest* destroy_object);
  private:
  const ::uesynth::DestroyObjectRequest& _internal_destroy_object() const;
  ::uesynth::DestroyObjectRequest* _internal_mutable_destroy_object();
  public:
  void unsafe_arena_set_allocated_destroy_object(
      ::uesynth::DestroyObjectRequest* destroy_object);
  ::uesynth::DestroyObjectRequest* unsafe_arena_release_destroy_object();
  // .uesynth.SetMaterialRequest set_material = 16;
  bool has_set_material() const;
  private:
  bool _internal_has_set_material() const;

  public:
  void clear_set_material() ;
  const ::uesynth::SetMaterialRequest& set_material() const;
  PROTOBUF_NODISCARD ::uesynth::SetMaterialRequest* release_set_material();
  ::uesynth::SetMaterialRequest* mutable_set_material();
  void set_allocated_set_material(::uesynth::SetMaterialRequest* set_material);
  private:
  const ::uesynth::SetMaterialRequest& _internal_set_material() const;
  ::uesynth::SetMaterialRequest* _internal_mutable_set_material();
  public:
  void unsafe_arena_set_allocated_set_material(
      ::uesynth::SetMaterialRequest* set_material);
  ::uesynth::SetMaterialRequest* unsafe_arena_release_set_material();
  // .google.protobuf.Empty list_objects = 17;
  bool has_list_objects() const;
  private:
  bool _internal_has_list_objects() const;

  public:
  void clear_list_objects() ;
  const ::PROTOBUF_NAMESPACE_ID::Empty& list_objects() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Empty* release_list_objects();
  ::PROTOBUF_NAMESPACE_ID::Empty* mutable_list_objects();
  void set_allocated_list_objects(::PROTOBUF_NAMESPACE_ID::Empty* list_objects);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Empty& _internal_list_objects() const;
  ::PROTOBUF_NAMESPACE_ID::Empty* _internal_mutable_list_objects();
  public:
  void unsafe_arena_set_allocated_list_objects(
      ::PROTOBUF_NAMESPACE_ID::Empty* list_objects);
  ::PROTOBUF_NAMESPACE_ID::Empty* unsafe_arena_release_list_objects();
  // .uesynth.SetLightingRequest set_lighting = 18;
  bool has_set_lighting() const;
  private:
  bool _internal_has_set_lighting() const;

  public:
  void clear_set_lighting() ;
  const ::uesynth::SetLightingRequest& set_lighting() const;
  PROTOBUF_NODISCARD ::uesynth::SetLightingRequest* release_set_lighting();
  ::uesynth::SetLightingRequest* mutable_set_lighting();
  void set_allocated_set_lighting(::uesynth::SetLightingRequest* set_lighting);
  private:
  const ::uesynth::SetLightingRequest& _internal_set_lighting() const;
  ::uesynth::SetLightingRequest* _internal_mutable_set_lighting();
  public:
  void unsafe_arena_set_allocated_set_lighting(
      ::uesynth::SetLightingRequest* set_lighting);
  ::uesynth::SetLightingRequest* unsafe_arena_release_set_lighting();
  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:uesynth.ActionRequest)
 private:
  class _Internal;
  void set_has_set_camera_transform();
  void set_has_get_camera_transform();
  void set_has_capture_rgb();
  void set_has_capture_depth();
  void set_has_capture_segmentation();
  void set_has_capture_normals();
  void set_has_capture_optical_flow();
  void set_has_set_object_transform();
  void set_has_get_object_transform();
  void set_has_create_camera();
  void set_has_destroy_camera();
  void set_has_set_resolution();
  void set_has_spawn_object();
  void set_has_destroy_object();
  void set_has_set_material();
  void set_has_list_objects();
  void set_has_set_lighting();

  inline bool has_action() const;
  inline void clear_has_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    union ActionUnion {
      constexpr ActionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::uesynth::SetCameraTransformRequest* set_camera_transform_;
      ::uesynth::GetCameraTransformRequest* get_camera_transform_;
      ::uesynth::CaptureRequest* capture_rgb_;
      ::uesynth::CaptureRequest* capture_depth_;
      ::uesynth::CaptureRequest* capture_segmentation_;
      ::uesynth::CaptureRequest* capture_normals_;
      ::uesynth::CaptureRequest* capture_optical_flow_;
      ::uesynth::SetObjectTransformRequest* set_object_transform_;
      ::uesynth::GetObjectTransformRequest* get_object_transform_;
      ::uesynth::CreateCameraRequest* create_camera_;
      ::uesynth::DestroyCameraRequest* destroy_camera_;
      ::uesynth::SetResolutionRequest* set_resolution_;
      ::uesynth::SpawnObjectRequest* spawn_object_;
      ::uesynth::DestroyObjectRequest* destroy_object_;
      ::uesynth::SetMaterialRequest* set_material_;
      ::PROTOBUF_NAMESPACE_ID::Empty* list_objects_;
      ::uesynth::SetLightingRequest* set_lighting_;
    } action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class FrameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.FrameResponse) */ {
 public:
  inline FrameResponse() : FrameResponse(nullptr) {}
  ~FrameResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FrameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameResponse(const FrameResponse& from);
  FrameResponse(FrameResponse&& from) noexcept
    : FrameResponse() {
    *this = ::std::move(from);
  }

  inline FrameResponse& operator=(const FrameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameResponse& operator=(FrameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kCommandResponse = 2,
    kCameraTransform = 3,
    kImageResponse = 4,
    kObjectTransform = 5,
    kObjectsList = 6,
    RESPONSE_NOT_SET = 0,
  };

  static inline const FrameResponse* internal_default_instance() {
    return reinterpret_cast<const FrameResponse*>(
               &_FrameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FrameResponse& a, FrameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrameResponse& from) {
    FrameResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.FrameResponse";
  }
  protected:
  explicit FrameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kCommandResponseFieldNumber = 2,
    kCameraTransformFieldNumber = 3,
    kImageResponseFieldNumber = 4,
    kObjectTransformFieldNumber = 5,
    kObjectsListFieldNumber = 6,
  };
  // string request_id = 1;
  void clear_request_id() ;
  const std::string& request_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_request_id(Arg_&& arg, Args_... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* ptr);

  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(
      const std::string& value);
  std::string* _internal_mutable_request_id();

  public:
  // .uesynth.CommandResponse command_response = 2;
  bool has_command_response() const;
  private:
  bool _internal_has_command_response() const;

  public:
  void clear_command_response() ;
  const ::uesynth::CommandResponse& command_response() const;
  PROTOBUF_NODISCARD ::uesynth::CommandResponse* release_command_response();
  ::uesynth::CommandResponse* mutable_command_response();
  void set_allocated_command_response(::uesynth::CommandResponse* command_response);
  private:
  const ::uesynth::CommandResponse& _internal_command_response() const;
  ::uesynth::CommandResponse* _internal_mutable_command_response();
  public:
  void unsafe_arena_set_allocated_command_response(
      ::uesynth::CommandResponse* command_response);
  ::uesynth::CommandResponse* unsafe_arena_release_command_response();
  // .uesynth.GetCameraTransformResponse camera_transform = 3;
  bool has_camera_transform() const;
  private:
  bool _internal_has_camera_transform() const;

  public:
  void clear_camera_transform() ;
  const ::uesynth::GetCameraTransformResponse& camera_transform() const;
  PROTOBUF_NODISCARD ::uesynth::GetCameraTransformResponse* release_camera_transform();
  ::uesynth::GetCameraTransformResponse* mutable_camera_transform();
  void set_allocated_camera_transform(::uesynth::GetCameraTransformResponse* camera_transform);
  private:
  const ::uesynth::GetCameraTransformResponse& _internal_camera_transform() const;
  ::uesynth::GetCameraTransformResponse* _internal_mutable_camera_transform();
  public:
  void unsafe_arena_set_allocated_camera_transform(
      ::uesynth::GetCameraTransformResponse* camera_transform);
  ::uesynth::GetCameraTransformResponse* unsafe_arena_release_camera_transform();
  // .uesynth.ImageResponse image_response = 4;
  bool has_image_response() const;
  private:
  bool _internal_has_image_response() const;

  public:
  void clear_image_response() ;
  const ::uesynth::ImageResponse& image_response() const;
  PROTOBUF_NODISCARD ::uesynth::ImageResponse* release_image_response();
  ::uesynth::ImageResponse* mutable_image_response();
  void set_allocated_image_response(::uesynth::ImageResponse* image_response);
  private:
  const ::uesynth::ImageResponse& _internal_image_response() const;
  ::uesynth::ImageResponse* _internal_mutable_image_response();
  public:
  void unsafe_arena_set_allocated_image_response(
      ::uesynth::ImageResponse* image_response);
  ::uesynth::ImageResponse* unsafe_arena_release_image_response();
  // .uesynth.GetObjectTransformResponse object_transform = 5;
  bool has_object_transform() const;
  private:
  bool _internal_has_object_transform() const;

  public:
  void clear_object_transform() ;
  const ::uesynth::GetObjectTransformResponse& object_transform() const;
  PROTOBUF_NODISCARD ::uesynth::GetObjectTransformResponse* release_object_transform();
  ::uesynth::GetObjectTransformResponse* mutable_object_transform();
  void set_allocated_object_transform(::uesynth::GetObjectTransformResponse* object_transform);
  private:
  const ::uesynth::GetObjectTransformResponse& _internal_object_transform() const;
  ::uesynth::GetObjectTransformResponse* _internal_mutable_object_transform();
  public:
  void unsafe_arena_set_allocated_object_transform(
      ::uesynth::GetObjectTransformResponse* object_transform);
  ::uesynth::GetObjectTransformResponse* unsafe_arena_release_object_transform();
  // .uesynth.ListObjectsResponse objects_list = 6;
  bool has_objects_list() const;
  private:
  bool _internal_has_objects_list() const;

  public:
  void clear_objects_list() ;
  const ::uesynth::ListObjectsResponse& objects_list() const;
  PROTOBUF_NODISCARD ::uesynth::ListObjectsResponse* release_objects_list();
  ::uesynth::ListObjectsResponse* mutable_objects_list();
  void set_allocated_objects_list(::uesynth::ListObjectsResponse* objects_list);
  private:
  const ::uesynth::ListObjectsResponse& _internal_objects_list() const;
  ::uesynth::ListObjectsResponse* _internal_mutable_objects_list();
  public:
  void unsafe_arena_set_allocated_objects_list(
      ::uesynth::ListObjectsResponse* objects_list);
  ::uesynth::ListObjectsResponse* unsafe_arena_release_objects_list();
  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:uesynth.FrameResponse)
 private:
  class _Internal;
  void set_has_command_response();
  void set_has_camera_transform();
  void set_has_image_response();
  void set_has_object_transform();
  void set_has_objects_list();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::uesynth::CommandResponse* command_response_;
      ::uesynth::GetCameraTransformResponse* camera_transform_;
      ::uesynth::ImageResponse* image_response_;
      ::uesynth::GetObjectTransformResponse* object_transform_;
      ::uesynth::ListObjectsResponse* objects_list_;
    } response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class Vector3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  ~Vector3() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vector3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector3(const Vector3& from);
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vector3& from) {
    Vector3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.Vector3";
  }
  protected:
  explicit Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:uesynth.Vector3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class Rotator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.Rotator) */ {
 public:
  inline Rotator() : Rotator(nullptr) {}
  ~Rotator() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rotator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rotator(const Rotator& from);
  Rotator(Rotator&& from) noexcept
    : Rotator() {
    *this = ::std::move(from);
  }

  inline Rotator& operator=(const Rotator& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rotator& operator=(Rotator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rotator& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rotator* internal_default_instance() {
    return reinterpret_cast<const Rotator*>(
               &_Rotator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Rotator& a, Rotator& b) {
    a.Swap(&b);
  }
  inline void Swap(Rotator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rotator* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rotator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rotator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rotator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rotator& from) {
    Rotator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rotator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.Rotator";
  }
  protected:
  explicit Rotator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPitchFieldNumber = 1,
    kYawFieldNumber = 2,
    kRollFieldNumber = 3,
  };
  // float pitch = 1;
  void clear_pitch() ;
  float pitch() const;
  void set_pitch(float value);

  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);

  public:
  // float yaw = 2;
  void clear_yaw() ;
  float yaw() const;
  void set_yaw(float value);

  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);

  public:
  // float roll = 3;
  void clear_roll() ;
  float roll() const;
  void set_roll(float value);

  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);

  public:
  // @@protoc_insertion_point(class_scope:uesynth.Rotator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float pitch_;
    float yaw_;
    float roll_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class Transform final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.Transform) */ {
 public:
  inline Transform() : Transform(nullptr) {}
  ~Transform() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Transform(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transform(const Transform& from);
  Transform(Transform&& from) noexcept
    : Transform() {
    *this = ::std::move(from);
  }

  inline Transform& operator=(const Transform& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transform& operator=(Transform&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transform& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transform* internal_default_instance() {
    return reinterpret_cast<const Transform*>(
               &_Transform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Transform& a, Transform& b) {
    a.Swap(&b);
  }
  inline void Swap(Transform* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transform* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transform* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transform>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transform& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Transform& from) {
    Transform::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transform* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.Transform";
  }
  protected:
  explicit Transform(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kRotationFieldNumber = 2,
    kScaleFieldNumber = 3,
  };
  // .uesynth.Vector3 location = 1;
  bool has_location() const;
  void clear_location() ;
  const ::uesynth::Vector3& location() const;
  PROTOBUF_NODISCARD ::uesynth::Vector3* release_location();
  ::uesynth::Vector3* mutable_location();
  void set_allocated_location(::uesynth::Vector3* location);
  private:
  const ::uesynth::Vector3& _internal_location() const;
  ::uesynth::Vector3* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::uesynth::Vector3* location);
  ::uesynth::Vector3* unsafe_arena_release_location();
  // .uesynth.Rotator rotation = 2;
  bool has_rotation() const;
  void clear_rotation() ;
  const ::uesynth::Rotator& rotation() const;
  PROTOBUF_NODISCARD ::uesynth::Rotator* release_rotation();
  ::uesynth::Rotator* mutable_rotation();
  void set_allocated_rotation(::uesynth::Rotator* rotation);
  private:
  const ::uesynth::Rotator& _internal_rotation() const;
  ::uesynth::Rotator* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::uesynth::Rotator* rotation);
  ::uesynth::Rotator* unsafe_arena_release_rotation();
  // .uesynth.Vector3 scale = 3;
  bool has_scale() const;
  void clear_scale() ;
  const ::uesynth::Vector3& scale() const;
  PROTOBUF_NODISCARD ::uesynth::Vector3* release_scale();
  ::uesynth::Vector3* mutable_scale();
  void set_allocated_scale(::uesynth::Vector3* scale);
  private:
  const ::uesynth::Vector3& _internal_scale() const;
  ::uesynth::Vector3* _internal_mutable_scale();
  public:
  void unsafe_arena_set_allocated_scale(
      ::uesynth::Vector3* scale);
  ::uesynth::Vector3* unsafe_arena_release_scale();
  // @@protoc_insertion_point(class_scope:uesynth.Transform)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uesynth::Vector3* location_;
    ::uesynth::Rotator* rotation_;
    ::uesynth::Vector3* scale_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class CommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.CommandResponse) */ {
 public:
  inline CommandResponse() : CommandResponse(nullptr) {}
  ~CommandResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandResponse(const CommandResponse& from);
  CommandResponse(CommandResponse&& from) noexcept
    : CommandResponse() {
    *this = ::std::move(from);
  }

  inline CommandResponse& operator=(const CommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandResponse& operator=(CommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandResponse* internal_default_instance() {
    return reinterpret_cast<const CommandResponse*>(
               &_CommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CommandResponse& a, CommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommandResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommandResponse& from) {
    CommandResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.CommandResponse";
  }
  protected:
  explicit CommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:uesynth.CommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class SetCameraTransformRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.SetCameraTransformRequest) */ {
 public:
  inline SetCameraTransformRequest() : SetCameraTransformRequest(nullptr) {}
  ~SetCameraTransformRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetCameraTransformRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetCameraTransformRequest(const SetCameraTransformRequest& from);
  SetCameraTransformRequest(SetCameraTransformRequest&& from) noexcept
    : SetCameraTransformRequest() {
    *this = ::std::move(from);
  }

  inline SetCameraTransformRequest& operator=(const SetCameraTransformRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetCameraTransformRequest& operator=(SetCameraTransformRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetCameraTransformRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetCameraTransformRequest* internal_default_instance() {
    return reinterpret_cast<const SetCameraTransformRequest*>(
               &_SetCameraTransformRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SetCameraTransformRequest& a, SetCameraTransformRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetCameraTransformRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetCameraTransformRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetCameraTransformRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetCameraTransformRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetCameraTransformRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetCameraTransformRequest& from) {
    SetCameraTransformRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetCameraTransformRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.SetCameraTransformRequest";
  }
  protected:
  explicit SetCameraTransformRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraNameFieldNumber = 1,
    kTransformFieldNumber = 2,
  };
  // string camera_name = 1;
  void clear_camera_name() ;
  const std::string& camera_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_camera_name(Arg_&& arg, Args_... args);
  std::string* mutable_camera_name();
  PROTOBUF_NODISCARD std::string* release_camera_name();
  void set_allocated_camera_name(std::string* ptr);

  private:
  const std::string& _internal_camera_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_name(
      const std::string& value);
  std::string* _internal_mutable_camera_name();

  public:
  // .uesynth.Transform transform = 2;
  bool has_transform() const;
  void clear_transform() ;
  const ::uesynth::Transform& transform() const;
  PROTOBUF_NODISCARD ::uesynth::Transform* release_transform();
  ::uesynth::Transform* mutable_transform();
  void set_allocated_transform(::uesynth::Transform* transform);
  private:
  const ::uesynth::Transform& _internal_transform() const;
  ::uesynth::Transform* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::uesynth::Transform* transform);
  ::uesynth::Transform* unsafe_arena_release_transform();
  // @@protoc_insertion_point(class_scope:uesynth.SetCameraTransformRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_name_;
    ::uesynth::Transform* transform_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class GetCameraTransformRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.GetCameraTransformRequest) */ {
 public:
  inline GetCameraTransformRequest() : GetCameraTransformRequest(nullptr) {}
  ~GetCameraTransformRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetCameraTransformRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCameraTransformRequest(const GetCameraTransformRequest& from);
  GetCameraTransformRequest(GetCameraTransformRequest&& from) noexcept
    : GetCameraTransformRequest() {
    *this = ::std::move(from);
  }

  inline GetCameraTransformRequest& operator=(const GetCameraTransformRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCameraTransformRequest& operator=(GetCameraTransformRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCameraTransformRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCameraTransformRequest* internal_default_instance() {
    return reinterpret_cast<const GetCameraTransformRequest*>(
               &_GetCameraTransformRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetCameraTransformRequest& a, GetCameraTransformRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCameraTransformRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCameraTransformRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCameraTransformRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCameraTransformRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCameraTransformRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetCameraTransformRequest& from) {
    GetCameraTransformRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCameraTransformRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.GetCameraTransformRequest";
  }
  protected:
  explicit GetCameraTransformRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraNameFieldNumber = 1,
  };
  // string camera_name = 1;
  void clear_camera_name() ;
  const std::string& camera_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_camera_name(Arg_&& arg, Args_... args);
  std::string* mutable_camera_name();
  PROTOBUF_NODISCARD std::string* release_camera_name();
  void set_allocated_camera_name(std::string* ptr);

  private:
  const std::string& _internal_camera_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_name(
      const std::string& value);
  std::string* _internal_mutable_camera_name();

  public:
  // @@protoc_insertion_point(class_scope:uesynth.GetCameraTransformRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class GetCameraTransformResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.GetCameraTransformResponse) */ {
 public:
  inline GetCameraTransformResponse() : GetCameraTransformResponse(nullptr) {}
  ~GetCameraTransformResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetCameraTransformResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCameraTransformResponse(const GetCameraTransformResponse& from);
  GetCameraTransformResponse(GetCameraTransformResponse&& from) noexcept
    : GetCameraTransformResponse() {
    *this = ::std::move(from);
  }

  inline GetCameraTransformResponse& operator=(const GetCameraTransformResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCameraTransformResponse& operator=(GetCameraTransformResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCameraTransformResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCameraTransformResponse* internal_default_instance() {
    return reinterpret_cast<const GetCameraTransformResponse*>(
               &_GetCameraTransformResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetCameraTransformResponse& a, GetCameraTransformResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCameraTransformResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCameraTransformResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCameraTransformResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCameraTransformResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCameraTransformResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetCameraTransformResponse& from) {
    GetCameraTransformResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCameraTransformResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.GetCameraTransformResponse";
  }
  protected:
  explicit GetCameraTransformResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kTransformFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // string message = 3;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .uesynth.Transform transform = 1;
  bool has_transform() const;
  void clear_transform() ;
  const ::uesynth::Transform& transform() const;
  PROTOBUF_NODISCARD ::uesynth::Transform* release_transform();
  ::uesynth::Transform* mutable_transform();
  void set_allocated_transform(::uesynth::Transform* transform);
  private:
  const ::uesynth::Transform& _internal_transform() const;
  ::uesynth::Transform* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::uesynth::Transform* transform);
  ::uesynth::Transform* unsafe_arena_release_transform();
  // bool success = 2;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:uesynth.GetCameraTransformResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::uesynth::Transform* transform_;
    bool success_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class CaptureRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.CaptureRequest) */ {
 public:
  inline CaptureRequest() : CaptureRequest(nullptr) {}
  ~CaptureRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CaptureRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaptureRequest(const CaptureRequest& from);
  CaptureRequest(CaptureRequest&& from) noexcept
    : CaptureRequest() {
    *this = ::std::move(from);
  }

  inline CaptureRequest& operator=(const CaptureRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptureRequest& operator=(CaptureRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaptureRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptureRequest* internal_default_instance() {
    return reinterpret_cast<const CaptureRequest*>(
               &_CaptureRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CaptureRequest& a, CaptureRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CaptureRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptureRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptureRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaptureRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaptureRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaptureRequest& from) {
    CaptureRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaptureRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.CaptureRequest";
  }
  protected:
  explicit CaptureRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraNameFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // string camera_name = 1;
  void clear_camera_name() ;
  const std::string& camera_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_camera_name(Arg_&& arg, Args_... args);
  std::string* mutable_camera_name();
  PROTOBUF_NODISCARD std::string* release_camera_name();
  void set_allocated_camera_name(std::string* ptr);

  private:
  const std::string& _internal_camera_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_name(
      const std::string& value);
  std::string* _internal_mutable_camera_name();

  public:
  // uint32 width = 2;
  void clear_width() ;
  ::uint32_t width() const;
  void set_width(::uint32_t value);

  private:
  ::uint32_t _internal_width() const;
  void _internal_set_width(::uint32_t value);

  public:
  // uint32 height = 3;
  void clear_height() ;
  ::uint32_t height() const;
  void set_height(::uint32_t value);

  private:
  ::uint32_t _internal_height() const;
  void _internal_set_height(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:uesynth.CaptureRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_name_;
    ::uint32_t width_;
    ::uint32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class ImageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.ImageResponse) */ {
 public:
  inline ImageResponse() : ImageResponse(nullptr) {}
  ~ImageResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ImageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageResponse(const ImageResponse& from);
  ImageResponse(ImageResponse&& from) noexcept
    : ImageResponse() {
    *this = ::std::move(from);
  }

  inline ImageResponse& operator=(const ImageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageResponse& operator=(ImageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageResponse* internal_default_instance() {
    return reinterpret_cast<const ImageResponse*>(
               &_ImageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ImageResponse& a, ImageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageResponse& from) {
    ImageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.ImageResponse";
  }
  protected:
  explicit ImageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageDataFieldNumber = 1,
    kFormatFieldNumber = 4,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // bytes image_data = 1;
  void clear_image_data() ;
  const std::string& image_data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_image_data(Arg_&& arg, Args_... args);
  std::string* mutable_image_data();
  PROTOBUF_NODISCARD std::string* release_image_data();
  void set_allocated_image_data(std::string* ptr);

  private:
  const std::string& _internal_image_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_data(
      const std::string& value);
  std::string* _internal_mutable_image_data();

  public:
  // string format = 4;
  void clear_format() ;
  const std::string& format() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_format(Arg_&& arg, Args_... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* ptr);

  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(
      const std::string& value);
  std::string* _internal_mutable_format();

  public:
  // uint32 width = 2;
  void clear_width() ;
  ::uint32_t width() const;
  void set_width(::uint32_t value);

  private:
  ::uint32_t _internal_width() const;
  void _internal_set_width(::uint32_t value);

  public:
  // uint32 height = 3;
  void clear_height() ;
  ::uint32_t height() const;
  void set_height(::uint32_t value);

  private:
  ::uint32_t _internal_height() const;
  void _internal_set_height(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:uesynth.ImageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
    ::uint32_t width_;
    ::uint32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class SetObjectTransformRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.SetObjectTransformRequest) */ {
 public:
  inline SetObjectTransformRequest() : SetObjectTransformRequest(nullptr) {}
  ~SetObjectTransformRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetObjectTransformRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetObjectTransformRequest(const SetObjectTransformRequest& from);
  SetObjectTransformRequest(SetObjectTransformRequest&& from) noexcept
    : SetObjectTransformRequest() {
    *this = ::std::move(from);
  }

  inline SetObjectTransformRequest& operator=(const SetObjectTransformRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetObjectTransformRequest& operator=(SetObjectTransformRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetObjectTransformRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetObjectTransformRequest* internal_default_instance() {
    return reinterpret_cast<const SetObjectTransformRequest*>(
               &_SetObjectTransformRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SetObjectTransformRequest& a, SetObjectTransformRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetObjectTransformRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetObjectTransformRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetObjectTransformRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetObjectTransformRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetObjectTransformRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetObjectTransformRequest& from) {
    SetObjectTransformRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetObjectTransformRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.SetObjectTransformRequest";
  }
  protected:
  explicit SetObjectTransformRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectNameFieldNumber = 1,
    kTransformFieldNumber = 2,
  };
  // string object_name = 1;
  void clear_object_name() ;
  const std::string& object_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_object_name(Arg_&& arg, Args_... args);
  std::string* mutable_object_name();
  PROTOBUF_NODISCARD std::string* release_object_name();
  void set_allocated_object_name(std::string* ptr);

  private:
  const std::string& _internal_object_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object_name(
      const std::string& value);
  std::string* _internal_mutable_object_name();

  public:
  // .uesynth.Transform transform = 2;
  bool has_transform() const;
  void clear_transform() ;
  const ::uesynth::Transform& transform() const;
  PROTOBUF_NODISCARD ::uesynth::Transform* release_transform();
  ::uesynth::Transform* mutable_transform();
  void set_allocated_transform(::uesynth::Transform* transform);
  private:
  const ::uesynth::Transform& _internal_transform() const;
  ::uesynth::Transform* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::uesynth::Transform* transform);
  ::uesynth::Transform* unsafe_arena_release_transform();
  // @@protoc_insertion_point(class_scope:uesynth.SetObjectTransformRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_name_;
    ::uesynth::Transform* transform_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class GetObjectTransformRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.GetObjectTransformRequest) */ {
 public:
  inline GetObjectTransformRequest() : GetObjectTransformRequest(nullptr) {}
  ~GetObjectTransformRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetObjectTransformRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetObjectTransformRequest(const GetObjectTransformRequest& from);
  GetObjectTransformRequest(GetObjectTransformRequest&& from) noexcept
    : GetObjectTransformRequest() {
    *this = ::std::move(from);
  }

  inline GetObjectTransformRequest& operator=(const GetObjectTransformRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetObjectTransformRequest& operator=(GetObjectTransformRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetObjectTransformRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetObjectTransformRequest* internal_default_instance() {
    return reinterpret_cast<const GetObjectTransformRequest*>(
               &_GetObjectTransformRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetObjectTransformRequest& a, GetObjectTransformRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetObjectTransformRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetObjectTransformRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetObjectTransformRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetObjectTransformRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetObjectTransformRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetObjectTransformRequest& from) {
    GetObjectTransformRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetObjectTransformRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.GetObjectTransformRequest";
  }
  protected:
  explicit GetObjectTransformRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectNameFieldNumber = 1,
  };
  // string object_name = 1;
  void clear_object_name() ;
  const std::string& object_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_object_name(Arg_&& arg, Args_... args);
  std::string* mutable_object_name();
  PROTOBUF_NODISCARD std::string* release_object_name();
  void set_allocated_object_name(std::string* ptr);

  private:
  const std::string& _internal_object_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object_name(
      const std::string& value);
  std::string* _internal_mutable_object_name();

  public:
  // @@protoc_insertion_point(class_scope:uesynth.GetObjectTransformRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class GetObjectTransformResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.GetObjectTransformResponse) */ {
 public:
  inline GetObjectTransformResponse() : GetObjectTransformResponse(nullptr) {}
  ~GetObjectTransformResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetObjectTransformResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetObjectTransformResponse(const GetObjectTransformResponse& from);
  GetObjectTransformResponse(GetObjectTransformResponse&& from) noexcept
    : GetObjectTransformResponse() {
    *this = ::std::move(from);
  }

  inline GetObjectTransformResponse& operator=(const GetObjectTransformResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetObjectTransformResponse& operator=(GetObjectTransformResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetObjectTransformResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetObjectTransformResponse* internal_default_instance() {
    return reinterpret_cast<const GetObjectTransformResponse*>(
               &_GetObjectTransformResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetObjectTransformResponse& a, GetObjectTransformResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetObjectTransformResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetObjectTransformResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetObjectTransformResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetObjectTransformResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetObjectTransformResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetObjectTransformResponse& from) {
    GetObjectTransformResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetObjectTransformResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.GetObjectTransformResponse";
  }
  protected:
  explicit GetObjectTransformResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kTransformFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // string message = 3;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .uesynth.Transform transform = 1;
  bool has_transform() const;
  void clear_transform() ;
  const ::uesynth::Transform& transform() const;
  PROTOBUF_NODISCARD ::uesynth::Transform* release_transform();
  ::uesynth::Transform* mutable_transform();
  void set_allocated_transform(::uesynth::Transform* transform);
  private:
  const ::uesynth::Transform& _internal_transform() const;
  ::uesynth::Transform* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::uesynth::Transform* transform);
  ::uesynth::Transform* unsafe_arena_release_transform();
  // bool success = 2;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:uesynth.GetObjectTransformResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::uesynth::Transform* transform_;
    bool success_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class CreateCameraRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.CreateCameraRequest) */ {
 public:
  inline CreateCameraRequest() : CreateCameraRequest(nullptr) {}
  ~CreateCameraRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateCameraRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCameraRequest(const CreateCameraRequest& from);
  CreateCameraRequest(CreateCameraRequest&& from) noexcept
    : CreateCameraRequest() {
    *this = ::std::move(from);
  }

  inline CreateCameraRequest& operator=(const CreateCameraRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCameraRequest& operator=(CreateCameraRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCameraRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCameraRequest* internal_default_instance() {
    return reinterpret_cast<const CreateCameraRequest*>(
               &_CreateCameraRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CreateCameraRequest& a, CreateCameraRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCameraRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCameraRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateCameraRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateCameraRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCameraRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateCameraRequest& from) {
    CreateCameraRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCameraRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.CreateCameraRequest";
  }
  protected:
  explicit CreateCameraRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraNameFieldNumber = 1,
    kInitialTransformFieldNumber = 2,
  };
  // string camera_name = 1;
  void clear_camera_name() ;
  const std::string& camera_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_camera_name(Arg_&& arg, Args_... args);
  std::string* mutable_camera_name();
  PROTOBUF_NODISCARD std::string* release_camera_name();
  void set_allocated_camera_name(std::string* ptr);

  private:
  const std::string& _internal_camera_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_name(
      const std::string& value);
  std::string* _internal_mutable_camera_name();

  public:
  // .uesynth.Transform initial_transform = 2;
  bool has_initial_transform() const;
  void clear_initial_transform() ;
  const ::uesynth::Transform& initial_transform() const;
  PROTOBUF_NODISCARD ::uesynth::Transform* release_initial_transform();
  ::uesynth::Transform* mutable_initial_transform();
  void set_allocated_initial_transform(::uesynth::Transform* initial_transform);
  private:
  const ::uesynth::Transform& _internal_initial_transform() const;
  ::uesynth::Transform* _internal_mutable_initial_transform();
  public:
  void unsafe_arena_set_allocated_initial_transform(
      ::uesynth::Transform* initial_transform);
  ::uesynth::Transform* unsafe_arena_release_initial_transform();
  // @@protoc_insertion_point(class_scope:uesynth.CreateCameraRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_name_;
    ::uesynth::Transform* initial_transform_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class DestroyCameraRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.DestroyCameraRequest) */ {
 public:
  inline DestroyCameraRequest() : DestroyCameraRequest(nullptr) {}
  ~DestroyCameraRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DestroyCameraRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DestroyCameraRequest(const DestroyCameraRequest& from);
  DestroyCameraRequest(DestroyCameraRequest&& from) noexcept
    : DestroyCameraRequest() {
    *this = ::std::move(from);
  }

  inline DestroyCameraRequest& operator=(const DestroyCameraRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestroyCameraRequest& operator=(DestroyCameraRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestroyCameraRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestroyCameraRequest* internal_default_instance() {
    return reinterpret_cast<const DestroyCameraRequest*>(
               &_DestroyCameraRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DestroyCameraRequest& a, DestroyCameraRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DestroyCameraRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestroyCameraRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestroyCameraRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestroyCameraRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DestroyCameraRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DestroyCameraRequest& from) {
    DestroyCameraRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DestroyCameraRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.DestroyCameraRequest";
  }
  protected:
  explicit DestroyCameraRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraNameFieldNumber = 1,
  };
  // string camera_name = 1;
  void clear_camera_name() ;
  const std::string& camera_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_camera_name(Arg_&& arg, Args_... args);
  std::string* mutable_camera_name();
  PROTOBUF_NODISCARD std::string* release_camera_name();
  void set_allocated_camera_name(std::string* ptr);

  private:
  const std::string& _internal_camera_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_name(
      const std::string& value);
  std::string* _internal_mutable_camera_name();

  public:
  // @@protoc_insertion_point(class_scope:uesynth.DestroyCameraRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class SetResolutionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.SetResolutionRequest) */ {
 public:
  inline SetResolutionRequest() : SetResolutionRequest(nullptr) {}
  ~SetResolutionRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetResolutionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetResolutionRequest(const SetResolutionRequest& from);
  SetResolutionRequest(SetResolutionRequest&& from) noexcept
    : SetResolutionRequest() {
    *this = ::std::move(from);
  }

  inline SetResolutionRequest& operator=(const SetResolutionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetResolutionRequest& operator=(SetResolutionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetResolutionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetResolutionRequest* internal_default_instance() {
    return reinterpret_cast<const SetResolutionRequest*>(
               &_SetResolutionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SetResolutionRequest& a, SetResolutionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetResolutionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetResolutionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetResolutionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetResolutionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetResolutionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetResolutionRequest& from) {
    SetResolutionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetResolutionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.SetResolutionRequest";
  }
  protected:
  explicit SetResolutionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraNameFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // string camera_name = 1;
  void clear_camera_name() ;
  const std::string& camera_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_camera_name(Arg_&& arg, Args_... args);
  std::string* mutable_camera_name();
  PROTOBUF_NODISCARD std::string* release_camera_name();
  void set_allocated_camera_name(std::string* ptr);

  private:
  const std::string& _internal_camera_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_name(
      const std::string& value);
  std::string* _internal_mutable_camera_name();

  public:
  // uint32 width = 2;
  void clear_width() ;
  ::uint32_t width() const;
  void set_width(::uint32_t value);

  private:
  ::uint32_t _internal_width() const;
  void _internal_set_width(::uint32_t value);

  public:
  // uint32 height = 3;
  void clear_height() ;
  ::uint32_t height() const;
  void set_height(::uint32_t value);

  private:
  ::uint32_t _internal_height() const;
  void _internal_set_height(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:uesynth.SetResolutionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_name_;
    ::uint32_t width_;
    ::uint32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class ListObjectsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.ListObjectsResponse) */ {
 public:
  inline ListObjectsResponse() : ListObjectsResponse(nullptr) {}
  ~ListObjectsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListObjectsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListObjectsResponse(const ListObjectsResponse& from);
  ListObjectsResponse(ListObjectsResponse&& from) noexcept
    : ListObjectsResponse() {
    *this = ::std::move(from);
  }

  inline ListObjectsResponse& operator=(const ListObjectsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListObjectsResponse& operator=(ListObjectsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListObjectsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListObjectsResponse* internal_default_instance() {
    return reinterpret_cast<const ListObjectsResponse*>(
               &_ListObjectsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ListObjectsResponse& a, ListObjectsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListObjectsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListObjectsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListObjectsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListObjectsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListObjectsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListObjectsResponse& from) {
    ListObjectsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListObjectsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.ListObjectsResponse";
  }
  protected:
  explicit ListObjectsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectNamesFieldNumber = 1,
  };
  // repeated string object_names = 1;
  int object_names_size() const;
  private:
  int _internal_object_names_size() const;

  public:
  void clear_object_names() ;
  const std::string& object_names(int index) const;
  std::string* mutable_object_names(int index);
  void set_object_names(int index, const std::string& value);
  void set_object_names(int index, std::string&& value);
  void set_object_names(int index, const char* value);
  void set_object_names(int index, const char* value, std::size_t size);
  void set_object_names(int index, absl::string_view value);
  std::string* add_object_names();
  void add_object_names(const std::string& value);
  void add_object_names(std::string&& value);
  void add_object_names(const char* value);
  void add_object_names(const char* value, std::size_t size);
  void add_object_names(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& object_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_object_names();

  private:
  const std::string& _internal_object_names(int index) const;
  std::string* _internal_add_object_names();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_object_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_object_names();

  public:
  // @@protoc_insertion_point(class_scope:uesynth.ListObjectsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> object_names_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class SpawnObjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.SpawnObjectRequest) */ {
 public:
  inline SpawnObjectRequest() : SpawnObjectRequest(nullptr) {}
  ~SpawnObjectRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpawnObjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpawnObjectRequest(const SpawnObjectRequest& from);
  SpawnObjectRequest(SpawnObjectRequest&& from) noexcept
    : SpawnObjectRequest() {
    *this = ::std::move(from);
  }

  inline SpawnObjectRequest& operator=(const SpawnObjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpawnObjectRequest& operator=(SpawnObjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpawnObjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpawnObjectRequest* internal_default_instance() {
    return reinterpret_cast<const SpawnObjectRequest*>(
               &_SpawnObjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SpawnObjectRequest& a, SpawnObjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SpawnObjectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpawnObjectRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpawnObjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpawnObjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpawnObjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpawnObjectRequest& from) {
    SpawnObjectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpawnObjectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.SpawnObjectRequest";
  }
  protected:
  explicit SpawnObjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectNameFieldNumber = 1,
    kAssetPathFieldNumber = 2,
    kInitialTransformFieldNumber = 3,
  };
  // string object_name = 1;
  void clear_object_name() ;
  const std::string& object_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_object_name(Arg_&& arg, Args_... args);
  std::string* mutable_object_name();
  PROTOBUF_NODISCARD std::string* release_object_name();
  void set_allocated_object_name(std::string* ptr);

  private:
  const std::string& _internal_object_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object_name(
      const std::string& value);
  std::string* _internal_mutable_object_name();

  public:
  // string asset_path = 2;
  void clear_asset_path() ;
  const std::string& asset_path() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_asset_path(Arg_&& arg, Args_... args);
  std::string* mutable_asset_path();
  PROTOBUF_NODISCARD std::string* release_asset_path();
  void set_allocated_asset_path(std::string* ptr);

  private:
  const std::string& _internal_asset_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_path(
      const std::string& value);
  std::string* _internal_mutable_asset_path();

  public:
  // .uesynth.Transform initial_transform = 3;
  bool has_initial_transform() const;
  void clear_initial_transform() ;
  const ::uesynth::Transform& initial_transform() const;
  PROTOBUF_NODISCARD ::uesynth::Transform* release_initial_transform();
  ::uesynth::Transform* mutable_initial_transform();
  void set_allocated_initial_transform(::uesynth::Transform* initial_transform);
  private:
  const ::uesynth::Transform& _internal_initial_transform() const;
  ::uesynth::Transform* _internal_mutable_initial_transform();
  public:
  void unsafe_arena_set_allocated_initial_transform(
      ::uesynth::Transform* initial_transform);
  ::uesynth::Transform* unsafe_arena_release_initial_transform();
  // @@protoc_insertion_point(class_scope:uesynth.SpawnObjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_path_;
    ::uesynth::Transform* initial_transform_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class DestroyObjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.DestroyObjectRequest) */ {
 public:
  inline DestroyObjectRequest() : DestroyObjectRequest(nullptr) {}
  ~DestroyObjectRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DestroyObjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DestroyObjectRequest(const DestroyObjectRequest& from);
  DestroyObjectRequest(DestroyObjectRequest&& from) noexcept
    : DestroyObjectRequest() {
    *this = ::std::move(from);
  }

  inline DestroyObjectRequest& operator=(const DestroyObjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestroyObjectRequest& operator=(DestroyObjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestroyObjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestroyObjectRequest* internal_default_instance() {
    return reinterpret_cast<const DestroyObjectRequest*>(
               &_DestroyObjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DestroyObjectRequest& a, DestroyObjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DestroyObjectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestroyObjectRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestroyObjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestroyObjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DestroyObjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DestroyObjectRequest& from) {
    DestroyObjectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DestroyObjectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.DestroyObjectRequest";
  }
  protected:
  explicit DestroyObjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectNameFieldNumber = 1,
  };
  // string object_name = 1;
  void clear_object_name() ;
  const std::string& object_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_object_name(Arg_&& arg, Args_... args);
  std::string* mutable_object_name();
  PROTOBUF_NODISCARD std::string* release_object_name();
  void set_allocated_object_name(std::string* ptr);

  private:
  const std::string& _internal_object_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object_name(
      const std::string& value);
  std::string* _internal_mutable_object_name();

  public:
  // @@protoc_insertion_point(class_scope:uesynth.DestroyObjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class SetMaterialRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.SetMaterialRequest) */ {
 public:
  inline SetMaterialRequest() : SetMaterialRequest(nullptr) {}
  ~SetMaterialRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetMaterialRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetMaterialRequest(const SetMaterialRequest& from);
  SetMaterialRequest(SetMaterialRequest&& from) noexcept
    : SetMaterialRequest() {
    *this = ::std::move(from);
  }

  inline SetMaterialRequest& operator=(const SetMaterialRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetMaterialRequest& operator=(SetMaterialRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetMaterialRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetMaterialRequest* internal_default_instance() {
    return reinterpret_cast<const SetMaterialRequest*>(
               &_SetMaterialRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SetMaterialRequest& a, SetMaterialRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetMaterialRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetMaterialRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetMaterialRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetMaterialRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetMaterialRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetMaterialRequest& from) {
    SetMaterialRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetMaterialRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.SetMaterialRequest";
  }
  protected:
  explicit SetMaterialRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectNameFieldNumber = 1,
    kMaterialPropertyFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // string object_name = 1;
  void clear_object_name() ;
  const std::string& object_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_object_name(Arg_&& arg, Args_... args);
  std::string* mutable_object_name();
  PROTOBUF_NODISCARD std::string* release_object_name();
  void set_allocated_object_name(std::string* ptr);

  private:
  const std::string& _internal_object_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object_name(
      const std::string& value);
  std::string* _internal_mutable_object_name();

  public:
  // string material_property = 2;
  void clear_material_property() ;
  const std::string& material_property() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_material_property(Arg_&& arg, Args_... args);
  std::string* mutable_material_property();
  PROTOBUF_NODISCARD std::string* release_material_property();
  void set_allocated_material_property(std::string* ptr);

  private:
  const std::string& _internal_material_property() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_material_property(
      const std::string& value);
  std::string* _internal_mutable_material_property();

  public:
  // string value = 3;
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:uesynth.SetMaterialRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr material_property_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};// -------------------------------------------------------------------

class SetLightingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uesynth.SetLightingRequest) */ {
 public:
  inline SetLightingRequest() : SetLightingRequest(nullptr) {}
  ~SetLightingRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetLightingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetLightingRequest(const SetLightingRequest& from);
  SetLightingRequest(SetLightingRequest&& from) noexcept
    : SetLightingRequest() {
    *this = ::std::move(from);
  }

  inline SetLightingRequest& operator=(const SetLightingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLightingRequest& operator=(SetLightingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetLightingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetLightingRequest* internal_default_instance() {
    return reinterpret_cast<const SetLightingRequest*>(
               &_SetLightingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SetLightingRequest& a, SetLightingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLightingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLightingRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetLightingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetLightingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetLightingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetLightingRequest& from) {
    SetLightingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLightingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "uesynth.SetLightingRequest";
  }
  protected:
  explicit SetLightingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLightNameFieldNumber = 1,
    kColorFieldNumber = 3,
    kTransformFieldNumber = 4,
    kIntensityFieldNumber = 2,
  };
  // string light_name = 1;
  void clear_light_name() ;
  const std::string& light_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_light_name(Arg_&& arg, Args_... args);
  std::string* mutable_light_name();
  PROTOBUF_NODISCARD std::string* release_light_name();
  void set_allocated_light_name(std::string* ptr);

  private:
  const std::string& _internal_light_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_light_name(
      const std::string& value);
  std::string* _internal_mutable_light_name();

  public:
  // .uesynth.Vector3 color = 3;
  bool has_color() const;
  void clear_color() ;
  const ::uesynth::Vector3& color() const;
  PROTOBUF_NODISCARD ::uesynth::Vector3* release_color();
  ::uesynth::Vector3* mutable_color();
  void set_allocated_color(::uesynth::Vector3* color);
  private:
  const ::uesynth::Vector3& _internal_color() const;
  ::uesynth::Vector3* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::uesynth::Vector3* color);
  ::uesynth::Vector3* unsafe_arena_release_color();
  // .uesynth.Transform transform = 4;
  bool has_transform() const;
  void clear_transform() ;
  const ::uesynth::Transform& transform() const;
  PROTOBUF_NODISCARD ::uesynth::Transform* release_transform();
  ::uesynth::Transform* mutable_transform();
  void set_allocated_transform(::uesynth::Transform* transform);
  private:
  const ::uesynth::Transform& _internal_transform() const;
  ::uesynth::Transform* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::uesynth::Transform* transform);
  ::uesynth::Transform* unsafe_arena_release_transform();
  // float intensity = 2;
  void clear_intensity() ;
  float intensity() const;
  void set_intensity(float value);

  private:
  float _internal_intensity() const;
  void _internal_set_intensity(float value);

  public:
  // @@protoc_insertion_point(class_scope:uesynth.SetLightingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr light_name_;
    ::uesynth::Vector3* color_;
    ::uesynth::Transform* transform_;
    float intensity_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uesynth_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ActionRequest

// string request_id = 1;
inline void ActionRequest::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& ActionRequest::request_id() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.request_id)
  return _internal_request_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ActionRequest::set_request_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.request_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.ActionRequest.request_id)
}
inline std::string* ActionRequest::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.request_id)
  return _s;
}
inline const std::string& ActionRequest::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void ActionRequest::_internal_set_request_id(const std::string& value) {
  ;


  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionRequest::_internal_mutable_request_id() {
  ;
  return _impl_.request_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ActionRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.request_id)
  return _impl_.request_id_.Release();
}
inline void ActionRequest::set_allocated_request_id(std::string* value) {
  _impl_.request_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.request_id_.IsDefault()) {
          _impl_.request_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.ActionRequest.request_id)
}

// .uesynth.SetCameraTransformRequest set_camera_transform = 2;
inline bool ActionRequest::has_set_camera_transform() const {
  return action_case() == kSetCameraTransform;
}
inline bool ActionRequest::_internal_has_set_camera_transform() const {
  return action_case() == kSetCameraTransform;
}
inline void ActionRequest::set_has_set_camera_transform() {
  _impl_._oneof_case_[0] = kSetCameraTransform;
}
inline void ActionRequest::clear_set_camera_transform() {
  if (action_case() == kSetCameraTransform) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.set_camera_transform_;
    }
    clear_has_action();
  }
}
inline ::uesynth::SetCameraTransformRequest* ActionRequest::release_set_camera_transform() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.set_camera_transform)
  if (action_case() == kSetCameraTransform) {
    clear_has_action();
    ::uesynth::SetCameraTransformRequest* temp = _impl_.action_.set_camera_transform_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.set_camera_transform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::SetCameraTransformRequest& ActionRequest::_internal_set_camera_transform() const {
  return action_case() == kSetCameraTransform
      ? *_impl_.action_.set_camera_transform_
      : reinterpret_cast<::uesynth::SetCameraTransformRequest&>(::uesynth::_SetCameraTransformRequest_default_instance_);
}
inline const ::uesynth::SetCameraTransformRequest& ActionRequest::set_camera_transform() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.set_camera_transform)
  return _internal_set_camera_transform();
}
inline ::uesynth::SetCameraTransformRequest* ActionRequest::unsafe_arena_release_set_camera_transform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.ActionRequest.set_camera_transform)
  if (action_case() == kSetCameraTransform) {
    clear_has_action();
    ::uesynth::SetCameraTransformRequest* temp = _impl_.action_.set_camera_transform_;
    _impl_.action_.set_camera_transform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRequest::unsafe_arena_set_allocated_set_camera_transform(::uesynth::SetCameraTransformRequest* set_camera_transform) {
  clear_action();
  if (set_camera_transform) {
    set_has_set_camera_transform();
    _impl_.action_.set_camera_transform_ = set_camera_transform;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.ActionRequest.set_camera_transform)
}
inline ::uesynth::SetCameraTransformRequest* ActionRequest::_internal_mutable_set_camera_transform() {
  if (action_case() != kSetCameraTransform) {
    clear_action();
    set_has_set_camera_transform();
    _impl_.action_.set_camera_transform_ = CreateMaybeMessage< ::uesynth::SetCameraTransformRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.set_camera_transform_;
}
inline ::uesynth::SetCameraTransformRequest* ActionRequest::mutable_set_camera_transform() {
  ::uesynth::SetCameraTransformRequest* _msg = _internal_mutable_set_camera_transform();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.set_camera_transform)
  return _msg;
}

// .uesynth.GetCameraTransformRequest get_camera_transform = 3;
inline bool ActionRequest::has_get_camera_transform() const {
  return action_case() == kGetCameraTransform;
}
inline bool ActionRequest::_internal_has_get_camera_transform() const {
  return action_case() == kGetCameraTransform;
}
inline void ActionRequest::set_has_get_camera_transform() {
  _impl_._oneof_case_[0] = kGetCameraTransform;
}
inline void ActionRequest::clear_get_camera_transform() {
  if (action_case() == kGetCameraTransform) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.get_camera_transform_;
    }
    clear_has_action();
  }
}
inline ::uesynth::GetCameraTransformRequest* ActionRequest::release_get_camera_transform() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.get_camera_transform)
  if (action_case() == kGetCameraTransform) {
    clear_has_action();
    ::uesynth::GetCameraTransformRequest* temp = _impl_.action_.get_camera_transform_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.get_camera_transform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::GetCameraTransformRequest& ActionRequest::_internal_get_camera_transform() const {
  return action_case() == kGetCameraTransform
      ? *_impl_.action_.get_camera_transform_
      : reinterpret_cast<::uesynth::GetCameraTransformRequest&>(::uesynth::_GetCameraTransformRequest_default_instance_);
}
inline const ::uesynth::GetCameraTransformRequest& ActionRequest::get_camera_transform() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.get_camera_transform)
  return _internal_get_camera_transform();
}
inline ::uesynth::GetCameraTransformRequest* ActionRequest::unsafe_arena_release_get_camera_transform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.ActionRequest.get_camera_transform)
  if (action_case() == kGetCameraTransform) {
    clear_has_action();
    ::uesynth::GetCameraTransformRequest* temp = _impl_.action_.get_camera_transform_;
    _impl_.action_.get_camera_transform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRequest::unsafe_arena_set_allocated_get_camera_transform(::uesynth::GetCameraTransformRequest* get_camera_transform) {
  clear_action();
  if (get_camera_transform) {
    set_has_get_camera_transform();
    _impl_.action_.get_camera_transform_ = get_camera_transform;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.ActionRequest.get_camera_transform)
}
inline ::uesynth::GetCameraTransformRequest* ActionRequest::_internal_mutable_get_camera_transform() {
  if (action_case() != kGetCameraTransform) {
    clear_action();
    set_has_get_camera_transform();
    _impl_.action_.get_camera_transform_ = CreateMaybeMessage< ::uesynth::GetCameraTransformRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.get_camera_transform_;
}
inline ::uesynth::GetCameraTransformRequest* ActionRequest::mutable_get_camera_transform() {
  ::uesynth::GetCameraTransformRequest* _msg = _internal_mutable_get_camera_transform();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.get_camera_transform)
  return _msg;
}

// .uesynth.CaptureRequest capture_rgb = 4;
inline bool ActionRequest::has_capture_rgb() const {
  return action_case() == kCaptureRgb;
}
inline bool ActionRequest::_internal_has_capture_rgb() const {
  return action_case() == kCaptureRgb;
}
inline void ActionRequest::set_has_capture_rgb() {
  _impl_._oneof_case_[0] = kCaptureRgb;
}
inline void ActionRequest::clear_capture_rgb() {
  if (action_case() == kCaptureRgb) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.capture_rgb_;
    }
    clear_has_action();
  }
}
inline ::uesynth::CaptureRequest* ActionRequest::release_capture_rgb() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.capture_rgb)
  if (action_case() == kCaptureRgb) {
    clear_has_action();
    ::uesynth::CaptureRequest* temp = _impl_.action_.capture_rgb_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.capture_rgb_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::CaptureRequest& ActionRequest::_internal_capture_rgb() const {
  return action_case() == kCaptureRgb
      ? *_impl_.action_.capture_rgb_
      : reinterpret_cast<::uesynth::CaptureRequest&>(::uesynth::_CaptureRequest_default_instance_);
}
inline const ::uesynth::CaptureRequest& ActionRequest::capture_rgb() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.capture_rgb)
  return _internal_capture_rgb();
}
inline ::uesynth::CaptureRequest* ActionRequest::unsafe_arena_release_capture_rgb() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.ActionRequest.capture_rgb)
  if (action_case() == kCaptureRgb) {
    clear_has_action();
    ::uesynth::CaptureRequest* temp = _impl_.action_.capture_rgb_;
    _impl_.action_.capture_rgb_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRequest::unsafe_arena_set_allocated_capture_rgb(::uesynth::CaptureRequest* capture_rgb) {
  clear_action();
  if (capture_rgb) {
    set_has_capture_rgb();
    _impl_.action_.capture_rgb_ = capture_rgb;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.ActionRequest.capture_rgb)
}
inline ::uesynth::CaptureRequest* ActionRequest::_internal_mutable_capture_rgb() {
  if (action_case() != kCaptureRgb) {
    clear_action();
    set_has_capture_rgb();
    _impl_.action_.capture_rgb_ = CreateMaybeMessage< ::uesynth::CaptureRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.capture_rgb_;
}
inline ::uesynth::CaptureRequest* ActionRequest::mutable_capture_rgb() {
  ::uesynth::CaptureRequest* _msg = _internal_mutable_capture_rgb();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.capture_rgb)
  return _msg;
}

// .uesynth.CaptureRequest capture_depth = 5;
inline bool ActionRequest::has_capture_depth() const {
  return action_case() == kCaptureDepth;
}
inline bool ActionRequest::_internal_has_capture_depth() const {
  return action_case() == kCaptureDepth;
}
inline void ActionRequest::set_has_capture_depth() {
  _impl_._oneof_case_[0] = kCaptureDepth;
}
inline void ActionRequest::clear_capture_depth() {
  if (action_case() == kCaptureDepth) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.capture_depth_;
    }
    clear_has_action();
  }
}
inline ::uesynth::CaptureRequest* ActionRequest::release_capture_depth() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.capture_depth)
  if (action_case() == kCaptureDepth) {
    clear_has_action();
    ::uesynth::CaptureRequest* temp = _impl_.action_.capture_depth_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.capture_depth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::CaptureRequest& ActionRequest::_internal_capture_depth() const {
  return action_case() == kCaptureDepth
      ? *_impl_.action_.capture_depth_
      : reinterpret_cast<::uesynth::CaptureRequest&>(::uesynth::_CaptureRequest_default_instance_);
}
inline const ::uesynth::CaptureRequest& ActionRequest::capture_depth() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.capture_depth)
  return _internal_capture_depth();
}
inline ::uesynth::CaptureRequest* ActionRequest::unsafe_arena_release_capture_depth() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.ActionRequest.capture_depth)
  if (action_case() == kCaptureDepth) {
    clear_has_action();
    ::uesynth::CaptureRequest* temp = _impl_.action_.capture_depth_;
    _impl_.action_.capture_depth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRequest::unsafe_arena_set_allocated_capture_depth(::uesynth::CaptureRequest* capture_depth) {
  clear_action();
  if (capture_depth) {
    set_has_capture_depth();
    _impl_.action_.capture_depth_ = capture_depth;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.ActionRequest.capture_depth)
}
inline ::uesynth::CaptureRequest* ActionRequest::_internal_mutable_capture_depth() {
  if (action_case() != kCaptureDepth) {
    clear_action();
    set_has_capture_depth();
    _impl_.action_.capture_depth_ = CreateMaybeMessage< ::uesynth::CaptureRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.capture_depth_;
}
inline ::uesynth::CaptureRequest* ActionRequest::mutable_capture_depth() {
  ::uesynth::CaptureRequest* _msg = _internal_mutable_capture_depth();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.capture_depth)
  return _msg;
}

// .uesynth.CaptureRequest capture_segmentation = 6;
inline bool ActionRequest::has_capture_segmentation() const {
  return action_case() == kCaptureSegmentation;
}
inline bool ActionRequest::_internal_has_capture_segmentation() const {
  return action_case() == kCaptureSegmentation;
}
inline void ActionRequest::set_has_capture_segmentation() {
  _impl_._oneof_case_[0] = kCaptureSegmentation;
}
inline void ActionRequest::clear_capture_segmentation() {
  if (action_case() == kCaptureSegmentation) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.capture_segmentation_;
    }
    clear_has_action();
  }
}
inline ::uesynth::CaptureRequest* ActionRequest::release_capture_segmentation() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.capture_segmentation)
  if (action_case() == kCaptureSegmentation) {
    clear_has_action();
    ::uesynth::CaptureRequest* temp = _impl_.action_.capture_segmentation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.capture_segmentation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::CaptureRequest& ActionRequest::_internal_capture_segmentation() const {
  return action_case() == kCaptureSegmentation
      ? *_impl_.action_.capture_segmentation_
      : reinterpret_cast<::uesynth::CaptureRequest&>(::uesynth::_CaptureRequest_default_instance_);
}
inline const ::uesynth::CaptureRequest& ActionRequest::capture_segmentation() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.capture_segmentation)
  return _internal_capture_segmentation();
}
inline ::uesynth::CaptureRequest* ActionRequest::unsafe_arena_release_capture_segmentation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.ActionRequest.capture_segmentation)
  if (action_case() == kCaptureSegmentation) {
    clear_has_action();
    ::uesynth::CaptureRequest* temp = _impl_.action_.capture_segmentation_;
    _impl_.action_.capture_segmentation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRequest::unsafe_arena_set_allocated_capture_segmentation(::uesynth::CaptureRequest* capture_segmentation) {
  clear_action();
  if (capture_segmentation) {
    set_has_capture_segmentation();
    _impl_.action_.capture_segmentation_ = capture_segmentation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.ActionRequest.capture_segmentation)
}
inline ::uesynth::CaptureRequest* ActionRequest::_internal_mutable_capture_segmentation() {
  if (action_case() != kCaptureSegmentation) {
    clear_action();
    set_has_capture_segmentation();
    _impl_.action_.capture_segmentation_ = CreateMaybeMessage< ::uesynth::CaptureRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.capture_segmentation_;
}
inline ::uesynth::CaptureRequest* ActionRequest::mutable_capture_segmentation() {
  ::uesynth::CaptureRequest* _msg = _internal_mutable_capture_segmentation();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.capture_segmentation)
  return _msg;
}

// .uesynth.CaptureRequest capture_normals = 7;
inline bool ActionRequest::has_capture_normals() const {
  return action_case() == kCaptureNormals;
}
inline bool ActionRequest::_internal_has_capture_normals() const {
  return action_case() == kCaptureNormals;
}
inline void ActionRequest::set_has_capture_normals() {
  _impl_._oneof_case_[0] = kCaptureNormals;
}
inline void ActionRequest::clear_capture_normals() {
  if (action_case() == kCaptureNormals) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.capture_normals_;
    }
    clear_has_action();
  }
}
inline ::uesynth::CaptureRequest* ActionRequest::release_capture_normals() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.capture_normals)
  if (action_case() == kCaptureNormals) {
    clear_has_action();
    ::uesynth::CaptureRequest* temp = _impl_.action_.capture_normals_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.capture_normals_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::CaptureRequest& ActionRequest::_internal_capture_normals() const {
  return action_case() == kCaptureNormals
      ? *_impl_.action_.capture_normals_
      : reinterpret_cast<::uesynth::CaptureRequest&>(::uesynth::_CaptureRequest_default_instance_);
}
inline const ::uesynth::CaptureRequest& ActionRequest::capture_normals() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.capture_normals)
  return _internal_capture_normals();
}
inline ::uesynth::CaptureRequest* ActionRequest::unsafe_arena_release_capture_normals() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.ActionRequest.capture_normals)
  if (action_case() == kCaptureNormals) {
    clear_has_action();
    ::uesynth::CaptureRequest* temp = _impl_.action_.capture_normals_;
    _impl_.action_.capture_normals_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRequest::unsafe_arena_set_allocated_capture_normals(::uesynth::CaptureRequest* capture_normals) {
  clear_action();
  if (capture_normals) {
    set_has_capture_normals();
    _impl_.action_.capture_normals_ = capture_normals;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.ActionRequest.capture_normals)
}
inline ::uesynth::CaptureRequest* ActionRequest::_internal_mutable_capture_normals() {
  if (action_case() != kCaptureNormals) {
    clear_action();
    set_has_capture_normals();
    _impl_.action_.capture_normals_ = CreateMaybeMessage< ::uesynth::CaptureRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.capture_normals_;
}
inline ::uesynth::CaptureRequest* ActionRequest::mutable_capture_normals() {
  ::uesynth::CaptureRequest* _msg = _internal_mutable_capture_normals();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.capture_normals)
  return _msg;
}

// .uesynth.CaptureRequest capture_optical_flow = 8;
inline bool ActionRequest::has_capture_optical_flow() const {
  return action_case() == kCaptureOpticalFlow;
}
inline bool ActionRequest::_internal_has_capture_optical_flow() const {
  return action_case() == kCaptureOpticalFlow;
}
inline void ActionRequest::set_has_capture_optical_flow() {
  _impl_._oneof_case_[0] = kCaptureOpticalFlow;
}
inline void ActionRequest::clear_capture_optical_flow() {
  if (action_case() == kCaptureOpticalFlow) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.capture_optical_flow_;
    }
    clear_has_action();
  }
}
inline ::uesynth::CaptureRequest* ActionRequest::release_capture_optical_flow() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.capture_optical_flow)
  if (action_case() == kCaptureOpticalFlow) {
    clear_has_action();
    ::uesynth::CaptureRequest* temp = _impl_.action_.capture_optical_flow_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.capture_optical_flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::CaptureRequest& ActionRequest::_internal_capture_optical_flow() const {
  return action_case() == kCaptureOpticalFlow
      ? *_impl_.action_.capture_optical_flow_
      : reinterpret_cast<::uesynth::CaptureRequest&>(::uesynth::_CaptureRequest_default_instance_);
}
inline const ::uesynth::CaptureRequest& ActionRequest::capture_optical_flow() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.capture_optical_flow)
  return _internal_capture_optical_flow();
}
inline ::uesynth::CaptureRequest* ActionRequest::unsafe_arena_release_capture_optical_flow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.ActionRequest.capture_optical_flow)
  if (action_case() == kCaptureOpticalFlow) {
    clear_has_action();
    ::uesynth::CaptureRequest* temp = _impl_.action_.capture_optical_flow_;
    _impl_.action_.capture_optical_flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRequest::unsafe_arena_set_allocated_capture_optical_flow(::uesynth::CaptureRequest* capture_optical_flow) {
  clear_action();
  if (capture_optical_flow) {
    set_has_capture_optical_flow();
    _impl_.action_.capture_optical_flow_ = capture_optical_flow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.ActionRequest.capture_optical_flow)
}
inline ::uesynth::CaptureRequest* ActionRequest::_internal_mutable_capture_optical_flow() {
  if (action_case() != kCaptureOpticalFlow) {
    clear_action();
    set_has_capture_optical_flow();
    _impl_.action_.capture_optical_flow_ = CreateMaybeMessage< ::uesynth::CaptureRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.capture_optical_flow_;
}
inline ::uesynth::CaptureRequest* ActionRequest::mutable_capture_optical_flow() {
  ::uesynth::CaptureRequest* _msg = _internal_mutable_capture_optical_flow();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.capture_optical_flow)
  return _msg;
}

// .uesynth.SetObjectTransformRequest set_object_transform = 9;
inline bool ActionRequest::has_set_object_transform() const {
  return action_case() == kSetObjectTransform;
}
inline bool ActionRequest::_internal_has_set_object_transform() const {
  return action_case() == kSetObjectTransform;
}
inline void ActionRequest::set_has_set_object_transform() {
  _impl_._oneof_case_[0] = kSetObjectTransform;
}
inline void ActionRequest::clear_set_object_transform() {
  if (action_case() == kSetObjectTransform) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.set_object_transform_;
    }
    clear_has_action();
  }
}
inline ::uesynth::SetObjectTransformRequest* ActionRequest::release_set_object_transform() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.set_object_transform)
  if (action_case() == kSetObjectTransform) {
    clear_has_action();
    ::uesynth::SetObjectTransformRequest* temp = _impl_.action_.set_object_transform_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.set_object_transform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::SetObjectTransformRequest& ActionRequest::_internal_set_object_transform() const {
  return action_case() == kSetObjectTransform
      ? *_impl_.action_.set_object_transform_
      : reinterpret_cast<::uesynth::SetObjectTransformRequest&>(::uesynth::_SetObjectTransformRequest_default_instance_);
}
inline const ::uesynth::SetObjectTransformRequest& ActionRequest::set_object_transform() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.set_object_transform)
  return _internal_set_object_transform();
}
inline ::uesynth::SetObjectTransformRequest* ActionRequest::unsafe_arena_release_set_object_transform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.ActionRequest.set_object_transform)
  if (action_case() == kSetObjectTransform) {
    clear_has_action();
    ::uesynth::SetObjectTransformRequest* temp = _impl_.action_.set_object_transform_;
    _impl_.action_.set_object_transform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRequest::unsafe_arena_set_allocated_set_object_transform(::uesynth::SetObjectTransformRequest* set_object_transform) {
  clear_action();
  if (set_object_transform) {
    set_has_set_object_transform();
    _impl_.action_.set_object_transform_ = set_object_transform;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.ActionRequest.set_object_transform)
}
inline ::uesynth::SetObjectTransformRequest* ActionRequest::_internal_mutable_set_object_transform() {
  if (action_case() != kSetObjectTransform) {
    clear_action();
    set_has_set_object_transform();
    _impl_.action_.set_object_transform_ = CreateMaybeMessage< ::uesynth::SetObjectTransformRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.set_object_transform_;
}
inline ::uesynth::SetObjectTransformRequest* ActionRequest::mutable_set_object_transform() {
  ::uesynth::SetObjectTransformRequest* _msg = _internal_mutable_set_object_transform();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.set_object_transform)
  return _msg;
}

// .uesynth.GetObjectTransformRequest get_object_transform = 10;
inline bool ActionRequest::has_get_object_transform() const {
  return action_case() == kGetObjectTransform;
}
inline bool ActionRequest::_internal_has_get_object_transform() const {
  return action_case() == kGetObjectTransform;
}
inline void ActionRequest::set_has_get_object_transform() {
  _impl_._oneof_case_[0] = kGetObjectTransform;
}
inline void ActionRequest::clear_get_object_transform() {
  if (action_case() == kGetObjectTransform) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.get_object_transform_;
    }
    clear_has_action();
  }
}
inline ::uesynth::GetObjectTransformRequest* ActionRequest::release_get_object_transform() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.get_object_transform)
  if (action_case() == kGetObjectTransform) {
    clear_has_action();
    ::uesynth::GetObjectTransformRequest* temp = _impl_.action_.get_object_transform_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.get_object_transform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::GetObjectTransformRequest& ActionRequest::_internal_get_object_transform() const {
  return action_case() == kGetObjectTransform
      ? *_impl_.action_.get_object_transform_
      : reinterpret_cast<::uesynth::GetObjectTransformRequest&>(::uesynth::_GetObjectTransformRequest_default_instance_);
}
inline const ::uesynth::GetObjectTransformRequest& ActionRequest::get_object_transform() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.get_object_transform)
  return _internal_get_object_transform();
}
inline ::uesynth::GetObjectTransformRequest* ActionRequest::unsafe_arena_release_get_object_transform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.ActionRequest.get_object_transform)
  if (action_case() == kGetObjectTransform) {
    clear_has_action();
    ::uesynth::GetObjectTransformRequest* temp = _impl_.action_.get_object_transform_;
    _impl_.action_.get_object_transform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRequest::unsafe_arena_set_allocated_get_object_transform(::uesynth::GetObjectTransformRequest* get_object_transform) {
  clear_action();
  if (get_object_transform) {
    set_has_get_object_transform();
    _impl_.action_.get_object_transform_ = get_object_transform;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.ActionRequest.get_object_transform)
}
inline ::uesynth::GetObjectTransformRequest* ActionRequest::_internal_mutable_get_object_transform() {
  if (action_case() != kGetObjectTransform) {
    clear_action();
    set_has_get_object_transform();
    _impl_.action_.get_object_transform_ = CreateMaybeMessage< ::uesynth::GetObjectTransformRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.get_object_transform_;
}
inline ::uesynth::GetObjectTransformRequest* ActionRequest::mutable_get_object_transform() {
  ::uesynth::GetObjectTransformRequest* _msg = _internal_mutable_get_object_transform();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.get_object_transform)
  return _msg;
}

// .uesynth.CreateCameraRequest create_camera = 11;
inline bool ActionRequest::has_create_camera() const {
  return action_case() == kCreateCamera;
}
inline bool ActionRequest::_internal_has_create_camera() const {
  return action_case() == kCreateCamera;
}
inline void ActionRequest::set_has_create_camera() {
  _impl_._oneof_case_[0] = kCreateCamera;
}
inline void ActionRequest::clear_create_camera() {
  if (action_case() == kCreateCamera) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.create_camera_;
    }
    clear_has_action();
  }
}
inline ::uesynth::CreateCameraRequest* ActionRequest::release_create_camera() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.create_camera)
  if (action_case() == kCreateCamera) {
    clear_has_action();
    ::uesynth::CreateCameraRequest* temp = _impl_.action_.create_camera_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.create_camera_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::CreateCameraRequest& ActionRequest::_internal_create_camera() const {
  return action_case() == kCreateCamera
      ? *_impl_.action_.create_camera_
      : reinterpret_cast<::uesynth::CreateCameraRequest&>(::uesynth::_CreateCameraRequest_default_instance_);
}
inline const ::uesynth::CreateCameraRequest& ActionRequest::create_camera() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.create_camera)
  return _internal_create_camera();
}
inline ::uesynth::CreateCameraRequest* ActionRequest::unsafe_arena_release_create_camera() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.ActionRequest.create_camera)
  if (action_case() == kCreateCamera) {
    clear_has_action();
    ::uesynth::CreateCameraRequest* temp = _impl_.action_.create_camera_;
    _impl_.action_.create_camera_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRequest::unsafe_arena_set_allocated_create_camera(::uesynth::CreateCameraRequest* create_camera) {
  clear_action();
  if (create_camera) {
    set_has_create_camera();
    _impl_.action_.create_camera_ = create_camera;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.ActionRequest.create_camera)
}
inline ::uesynth::CreateCameraRequest* ActionRequest::_internal_mutable_create_camera() {
  if (action_case() != kCreateCamera) {
    clear_action();
    set_has_create_camera();
    _impl_.action_.create_camera_ = CreateMaybeMessage< ::uesynth::CreateCameraRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.create_camera_;
}
inline ::uesynth::CreateCameraRequest* ActionRequest::mutable_create_camera() {
  ::uesynth::CreateCameraRequest* _msg = _internal_mutable_create_camera();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.create_camera)
  return _msg;
}

// .uesynth.DestroyCameraRequest destroy_camera = 12;
inline bool ActionRequest::has_destroy_camera() const {
  return action_case() == kDestroyCamera;
}
inline bool ActionRequest::_internal_has_destroy_camera() const {
  return action_case() == kDestroyCamera;
}
inline void ActionRequest::set_has_destroy_camera() {
  _impl_._oneof_case_[0] = kDestroyCamera;
}
inline void ActionRequest::clear_destroy_camera() {
  if (action_case() == kDestroyCamera) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.destroy_camera_;
    }
    clear_has_action();
  }
}
inline ::uesynth::DestroyCameraRequest* ActionRequest::release_destroy_camera() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.destroy_camera)
  if (action_case() == kDestroyCamera) {
    clear_has_action();
    ::uesynth::DestroyCameraRequest* temp = _impl_.action_.destroy_camera_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.destroy_camera_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::DestroyCameraRequest& ActionRequest::_internal_destroy_camera() const {
  return action_case() == kDestroyCamera
      ? *_impl_.action_.destroy_camera_
      : reinterpret_cast<::uesynth::DestroyCameraRequest&>(::uesynth::_DestroyCameraRequest_default_instance_);
}
inline const ::uesynth::DestroyCameraRequest& ActionRequest::destroy_camera() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.destroy_camera)
  return _internal_destroy_camera();
}
inline ::uesynth::DestroyCameraRequest* ActionRequest::unsafe_arena_release_destroy_camera() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.ActionRequest.destroy_camera)
  if (action_case() == kDestroyCamera) {
    clear_has_action();
    ::uesynth::DestroyCameraRequest* temp = _impl_.action_.destroy_camera_;
    _impl_.action_.destroy_camera_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRequest::unsafe_arena_set_allocated_destroy_camera(::uesynth::DestroyCameraRequest* destroy_camera) {
  clear_action();
  if (destroy_camera) {
    set_has_destroy_camera();
    _impl_.action_.destroy_camera_ = destroy_camera;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.ActionRequest.destroy_camera)
}
inline ::uesynth::DestroyCameraRequest* ActionRequest::_internal_mutable_destroy_camera() {
  if (action_case() != kDestroyCamera) {
    clear_action();
    set_has_destroy_camera();
    _impl_.action_.destroy_camera_ = CreateMaybeMessage< ::uesynth::DestroyCameraRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.destroy_camera_;
}
inline ::uesynth::DestroyCameraRequest* ActionRequest::mutable_destroy_camera() {
  ::uesynth::DestroyCameraRequest* _msg = _internal_mutable_destroy_camera();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.destroy_camera)
  return _msg;
}

// .uesynth.SetResolutionRequest set_resolution = 13;
inline bool ActionRequest::has_set_resolution() const {
  return action_case() == kSetResolution;
}
inline bool ActionRequest::_internal_has_set_resolution() const {
  return action_case() == kSetResolution;
}
inline void ActionRequest::set_has_set_resolution() {
  _impl_._oneof_case_[0] = kSetResolution;
}
inline void ActionRequest::clear_set_resolution() {
  if (action_case() == kSetResolution) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.set_resolution_;
    }
    clear_has_action();
  }
}
inline ::uesynth::SetResolutionRequest* ActionRequest::release_set_resolution() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.set_resolution)
  if (action_case() == kSetResolution) {
    clear_has_action();
    ::uesynth::SetResolutionRequest* temp = _impl_.action_.set_resolution_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.set_resolution_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::SetResolutionRequest& ActionRequest::_internal_set_resolution() const {
  return action_case() == kSetResolution
      ? *_impl_.action_.set_resolution_
      : reinterpret_cast<::uesynth::SetResolutionRequest&>(::uesynth::_SetResolutionRequest_default_instance_);
}
inline const ::uesynth::SetResolutionRequest& ActionRequest::set_resolution() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.set_resolution)
  return _internal_set_resolution();
}
inline ::uesynth::SetResolutionRequest* ActionRequest::unsafe_arena_release_set_resolution() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.ActionRequest.set_resolution)
  if (action_case() == kSetResolution) {
    clear_has_action();
    ::uesynth::SetResolutionRequest* temp = _impl_.action_.set_resolution_;
    _impl_.action_.set_resolution_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRequest::unsafe_arena_set_allocated_set_resolution(::uesynth::SetResolutionRequest* set_resolution) {
  clear_action();
  if (set_resolution) {
    set_has_set_resolution();
    _impl_.action_.set_resolution_ = set_resolution;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.ActionRequest.set_resolution)
}
inline ::uesynth::SetResolutionRequest* ActionRequest::_internal_mutable_set_resolution() {
  if (action_case() != kSetResolution) {
    clear_action();
    set_has_set_resolution();
    _impl_.action_.set_resolution_ = CreateMaybeMessage< ::uesynth::SetResolutionRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.set_resolution_;
}
inline ::uesynth::SetResolutionRequest* ActionRequest::mutable_set_resolution() {
  ::uesynth::SetResolutionRequest* _msg = _internal_mutable_set_resolution();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.set_resolution)
  return _msg;
}

// .uesynth.SpawnObjectRequest spawn_object = 14;
inline bool ActionRequest::has_spawn_object() const {
  return action_case() == kSpawnObject;
}
inline bool ActionRequest::_internal_has_spawn_object() const {
  return action_case() == kSpawnObject;
}
inline void ActionRequest::set_has_spawn_object() {
  _impl_._oneof_case_[0] = kSpawnObject;
}
inline void ActionRequest::clear_spawn_object() {
  if (action_case() == kSpawnObject) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.spawn_object_;
    }
    clear_has_action();
  }
}
inline ::uesynth::SpawnObjectRequest* ActionRequest::release_spawn_object() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.spawn_object)
  if (action_case() == kSpawnObject) {
    clear_has_action();
    ::uesynth::SpawnObjectRequest* temp = _impl_.action_.spawn_object_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.spawn_object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::SpawnObjectRequest& ActionRequest::_internal_spawn_object() const {
  return action_case() == kSpawnObject
      ? *_impl_.action_.spawn_object_
      : reinterpret_cast<::uesynth::SpawnObjectRequest&>(::uesynth::_SpawnObjectRequest_default_instance_);
}
inline const ::uesynth::SpawnObjectRequest& ActionRequest::spawn_object() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.spawn_object)
  return _internal_spawn_object();
}
inline ::uesynth::SpawnObjectRequest* ActionRequest::unsafe_arena_release_spawn_object() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.ActionRequest.spawn_object)
  if (action_case() == kSpawnObject) {
    clear_has_action();
    ::uesynth::SpawnObjectRequest* temp = _impl_.action_.spawn_object_;
    _impl_.action_.spawn_object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRequest::unsafe_arena_set_allocated_spawn_object(::uesynth::SpawnObjectRequest* spawn_object) {
  clear_action();
  if (spawn_object) {
    set_has_spawn_object();
    _impl_.action_.spawn_object_ = spawn_object;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.ActionRequest.spawn_object)
}
inline ::uesynth::SpawnObjectRequest* ActionRequest::_internal_mutable_spawn_object() {
  if (action_case() != kSpawnObject) {
    clear_action();
    set_has_spawn_object();
    _impl_.action_.spawn_object_ = CreateMaybeMessage< ::uesynth::SpawnObjectRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.spawn_object_;
}
inline ::uesynth::SpawnObjectRequest* ActionRequest::mutable_spawn_object() {
  ::uesynth::SpawnObjectRequest* _msg = _internal_mutable_spawn_object();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.spawn_object)
  return _msg;
}

// .uesynth.DestroyObjectRequest destroy_object = 15;
inline bool ActionRequest::has_destroy_object() const {
  return action_case() == kDestroyObject;
}
inline bool ActionRequest::_internal_has_destroy_object() const {
  return action_case() == kDestroyObject;
}
inline void ActionRequest::set_has_destroy_object() {
  _impl_._oneof_case_[0] = kDestroyObject;
}
inline void ActionRequest::clear_destroy_object() {
  if (action_case() == kDestroyObject) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.destroy_object_;
    }
    clear_has_action();
  }
}
inline ::uesynth::DestroyObjectRequest* ActionRequest::release_destroy_object() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.destroy_object)
  if (action_case() == kDestroyObject) {
    clear_has_action();
    ::uesynth::DestroyObjectRequest* temp = _impl_.action_.destroy_object_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.destroy_object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::DestroyObjectRequest& ActionRequest::_internal_destroy_object() const {
  return action_case() == kDestroyObject
      ? *_impl_.action_.destroy_object_
      : reinterpret_cast<::uesynth::DestroyObjectRequest&>(::uesynth::_DestroyObjectRequest_default_instance_);
}
inline const ::uesynth::DestroyObjectRequest& ActionRequest::destroy_object() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.destroy_object)
  return _internal_destroy_object();
}
inline ::uesynth::DestroyObjectRequest* ActionRequest::unsafe_arena_release_destroy_object() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.ActionRequest.destroy_object)
  if (action_case() == kDestroyObject) {
    clear_has_action();
    ::uesynth::DestroyObjectRequest* temp = _impl_.action_.destroy_object_;
    _impl_.action_.destroy_object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRequest::unsafe_arena_set_allocated_destroy_object(::uesynth::DestroyObjectRequest* destroy_object) {
  clear_action();
  if (destroy_object) {
    set_has_destroy_object();
    _impl_.action_.destroy_object_ = destroy_object;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.ActionRequest.destroy_object)
}
inline ::uesynth::DestroyObjectRequest* ActionRequest::_internal_mutable_destroy_object() {
  if (action_case() != kDestroyObject) {
    clear_action();
    set_has_destroy_object();
    _impl_.action_.destroy_object_ = CreateMaybeMessage< ::uesynth::DestroyObjectRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.destroy_object_;
}
inline ::uesynth::DestroyObjectRequest* ActionRequest::mutable_destroy_object() {
  ::uesynth::DestroyObjectRequest* _msg = _internal_mutable_destroy_object();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.destroy_object)
  return _msg;
}

// .uesynth.SetMaterialRequest set_material = 16;
inline bool ActionRequest::has_set_material() const {
  return action_case() == kSetMaterial;
}
inline bool ActionRequest::_internal_has_set_material() const {
  return action_case() == kSetMaterial;
}
inline void ActionRequest::set_has_set_material() {
  _impl_._oneof_case_[0] = kSetMaterial;
}
inline void ActionRequest::clear_set_material() {
  if (action_case() == kSetMaterial) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.set_material_;
    }
    clear_has_action();
  }
}
inline ::uesynth::SetMaterialRequest* ActionRequest::release_set_material() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.set_material)
  if (action_case() == kSetMaterial) {
    clear_has_action();
    ::uesynth::SetMaterialRequest* temp = _impl_.action_.set_material_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.set_material_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::SetMaterialRequest& ActionRequest::_internal_set_material() const {
  return action_case() == kSetMaterial
      ? *_impl_.action_.set_material_
      : reinterpret_cast<::uesynth::SetMaterialRequest&>(::uesynth::_SetMaterialRequest_default_instance_);
}
inline const ::uesynth::SetMaterialRequest& ActionRequest::set_material() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.set_material)
  return _internal_set_material();
}
inline ::uesynth::SetMaterialRequest* ActionRequest::unsafe_arena_release_set_material() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.ActionRequest.set_material)
  if (action_case() == kSetMaterial) {
    clear_has_action();
    ::uesynth::SetMaterialRequest* temp = _impl_.action_.set_material_;
    _impl_.action_.set_material_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRequest::unsafe_arena_set_allocated_set_material(::uesynth::SetMaterialRequest* set_material) {
  clear_action();
  if (set_material) {
    set_has_set_material();
    _impl_.action_.set_material_ = set_material;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.ActionRequest.set_material)
}
inline ::uesynth::SetMaterialRequest* ActionRequest::_internal_mutable_set_material() {
  if (action_case() != kSetMaterial) {
    clear_action();
    set_has_set_material();
    _impl_.action_.set_material_ = CreateMaybeMessage< ::uesynth::SetMaterialRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.set_material_;
}
inline ::uesynth::SetMaterialRequest* ActionRequest::mutable_set_material() {
  ::uesynth::SetMaterialRequest* _msg = _internal_mutable_set_material();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.set_material)
  return _msg;
}

// .google.protobuf.Empty list_objects = 17;
inline bool ActionRequest::has_list_objects() const {
  return action_case() == kListObjects;
}
inline bool ActionRequest::_internal_has_list_objects() const {
  return action_case() == kListObjects;
}
inline void ActionRequest::set_has_list_objects() {
  _impl_._oneof_case_[0] = kListObjects;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* ActionRequest::release_list_objects() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.list_objects)
  if (action_case() == kListObjects) {
    clear_has_action();
    ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.action_.list_objects_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.list_objects_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& ActionRequest::_internal_list_objects() const {
  return action_case() == kListObjects
      ? *_impl_.action_.list_objects_
      : reinterpret_cast<::PROTOBUF_NAMESPACE_ID::Empty&>(::PROTOBUF_NAMESPACE_ID::_Empty_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& ActionRequest::list_objects() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.list_objects)
  return _internal_list_objects();
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* ActionRequest::unsafe_arena_release_list_objects() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.ActionRequest.list_objects)
  if (action_case() == kListObjects) {
    clear_has_action();
    ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.action_.list_objects_;
    _impl_.action_.list_objects_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRequest::unsafe_arena_set_allocated_list_objects(::PROTOBUF_NAMESPACE_ID::Empty* list_objects) {
  clear_action();
  if (list_objects) {
    set_has_list_objects();
    _impl_.action_.list_objects_ = list_objects;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.ActionRequest.list_objects)
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* ActionRequest::_internal_mutable_list_objects() {
  if (action_case() != kListObjects) {
    clear_action();
    set_has_list_objects();
    _impl_.action_.list_objects_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Empty >(GetArenaForAllocation());
  }
  return _impl_.action_.list_objects_;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* ActionRequest::mutable_list_objects() {
  ::PROTOBUF_NAMESPACE_ID::Empty* _msg = _internal_mutable_list_objects();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.list_objects)
  return _msg;
}

// .uesynth.SetLightingRequest set_lighting = 18;
inline bool ActionRequest::has_set_lighting() const {
  return action_case() == kSetLighting;
}
inline bool ActionRequest::_internal_has_set_lighting() const {
  return action_case() == kSetLighting;
}
inline void ActionRequest::set_has_set_lighting() {
  _impl_._oneof_case_[0] = kSetLighting;
}
inline void ActionRequest::clear_set_lighting() {
  if (action_case() == kSetLighting) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.set_lighting_;
    }
    clear_has_action();
  }
}
inline ::uesynth::SetLightingRequest* ActionRequest::release_set_lighting() {
  // @@protoc_insertion_point(field_release:uesynth.ActionRequest.set_lighting)
  if (action_case() == kSetLighting) {
    clear_has_action();
    ::uesynth::SetLightingRequest* temp = _impl_.action_.set_lighting_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.set_lighting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::SetLightingRequest& ActionRequest::_internal_set_lighting() const {
  return action_case() == kSetLighting
      ? *_impl_.action_.set_lighting_
      : reinterpret_cast<::uesynth::SetLightingRequest&>(::uesynth::_SetLightingRequest_default_instance_);
}
inline const ::uesynth::SetLightingRequest& ActionRequest::set_lighting() const {
  // @@protoc_insertion_point(field_get:uesynth.ActionRequest.set_lighting)
  return _internal_set_lighting();
}
inline ::uesynth::SetLightingRequest* ActionRequest::unsafe_arena_release_set_lighting() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.ActionRequest.set_lighting)
  if (action_case() == kSetLighting) {
    clear_has_action();
    ::uesynth::SetLightingRequest* temp = _impl_.action_.set_lighting_;
    _impl_.action_.set_lighting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRequest::unsafe_arena_set_allocated_set_lighting(::uesynth::SetLightingRequest* set_lighting) {
  clear_action();
  if (set_lighting) {
    set_has_set_lighting();
    _impl_.action_.set_lighting_ = set_lighting;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.ActionRequest.set_lighting)
}
inline ::uesynth::SetLightingRequest* ActionRequest::_internal_mutable_set_lighting() {
  if (action_case() != kSetLighting) {
    clear_action();
    set_has_set_lighting();
    _impl_.action_.set_lighting_ = CreateMaybeMessage< ::uesynth::SetLightingRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.set_lighting_;
}
inline ::uesynth::SetLightingRequest* ActionRequest::mutable_set_lighting() {
  ::uesynth::SetLightingRequest* _msg = _internal_mutable_set_lighting();
  // @@protoc_insertion_point(field_mutable:uesynth.ActionRequest.set_lighting)
  return _msg;
}

inline bool ActionRequest::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ActionRequest::clear_has_action() {
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline ActionRequest::ActionCase ActionRequest::action_case() const {
  return ActionRequest::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FrameResponse

// string request_id = 1;
inline void FrameResponse::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& FrameResponse::request_id() const {
  // @@protoc_insertion_point(field_get:uesynth.FrameResponse.request_id)
  return _internal_request_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FrameResponse::set_request_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.request_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.FrameResponse.request_id)
}
inline std::string* FrameResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:uesynth.FrameResponse.request_id)
  return _s;
}
inline const std::string& FrameResponse::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void FrameResponse::_internal_set_request_id(const std::string& value) {
  ;


  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FrameResponse::_internal_mutable_request_id() {
  ;
  return _impl_.request_id_.Mutable( GetArenaForAllocation());
}
inline std::string* FrameResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:uesynth.FrameResponse.request_id)
  return _impl_.request_id_.Release();
}
inline void FrameResponse::set_allocated_request_id(std::string* value) {
  _impl_.request_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.request_id_.IsDefault()) {
          _impl_.request_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.FrameResponse.request_id)
}

// .uesynth.CommandResponse command_response = 2;
inline bool FrameResponse::has_command_response() const {
  return response_case() == kCommandResponse;
}
inline bool FrameResponse::_internal_has_command_response() const {
  return response_case() == kCommandResponse;
}
inline void FrameResponse::set_has_command_response() {
  _impl_._oneof_case_[0] = kCommandResponse;
}
inline void FrameResponse::clear_command_response() {
  if (response_case() == kCommandResponse) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.command_response_;
    }
    clear_has_response();
  }
}
inline ::uesynth::CommandResponse* FrameResponse::release_command_response() {
  // @@protoc_insertion_point(field_release:uesynth.FrameResponse.command_response)
  if (response_case() == kCommandResponse) {
    clear_has_response();
    ::uesynth::CommandResponse* temp = _impl_.response_.command_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.command_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::CommandResponse& FrameResponse::_internal_command_response() const {
  return response_case() == kCommandResponse
      ? *_impl_.response_.command_response_
      : reinterpret_cast<::uesynth::CommandResponse&>(::uesynth::_CommandResponse_default_instance_);
}
inline const ::uesynth::CommandResponse& FrameResponse::command_response() const {
  // @@protoc_insertion_point(field_get:uesynth.FrameResponse.command_response)
  return _internal_command_response();
}
inline ::uesynth::CommandResponse* FrameResponse::unsafe_arena_release_command_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.FrameResponse.command_response)
  if (response_case() == kCommandResponse) {
    clear_has_response();
    ::uesynth::CommandResponse* temp = _impl_.response_.command_response_;
    _impl_.response_.command_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FrameResponse::unsafe_arena_set_allocated_command_response(::uesynth::CommandResponse* command_response) {
  clear_response();
  if (command_response) {
    set_has_command_response();
    _impl_.response_.command_response_ = command_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.FrameResponse.command_response)
}
inline ::uesynth::CommandResponse* FrameResponse::_internal_mutable_command_response() {
  if (response_case() != kCommandResponse) {
    clear_response();
    set_has_command_response();
    _impl_.response_.command_response_ = CreateMaybeMessage< ::uesynth::CommandResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.command_response_;
}
inline ::uesynth::CommandResponse* FrameResponse::mutable_command_response() {
  ::uesynth::CommandResponse* _msg = _internal_mutable_command_response();
  // @@protoc_insertion_point(field_mutable:uesynth.FrameResponse.command_response)
  return _msg;
}

// .uesynth.GetCameraTransformResponse camera_transform = 3;
inline bool FrameResponse::has_camera_transform() const {
  return response_case() == kCameraTransform;
}
inline bool FrameResponse::_internal_has_camera_transform() const {
  return response_case() == kCameraTransform;
}
inline void FrameResponse::set_has_camera_transform() {
  _impl_._oneof_case_[0] = kCameraTransform;
}
inline void FrameResponse::clear_camera_transform() {
  if (response_case() == kCameraTransform) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.camera_transform_;
    }
    clear_has_response();
  }
}
inline ::uesynth::GetCameraTransformResponse* FrameResponse::release_camera_transform() {
  // @@protoc_insertion_point(field_release:uesynth.FrameResponse.camera_transform)
  if (response_case() == kCameraTransform) {
    clear_has_response();
    ::uesynth::GetCameraTransformResponse* temp = _impl_.response_.camera_transform_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.camera_transform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::GetCameraTransformResponse& FrameResponse::_internal_camera_transform() const {
  return response_case() == kCameraTransform
      ? *_impl_.response_.camera_transform_
      : reinterpret_cast<::uesynth::GetCameraTransformResponse&>(::uesynth::_GetCameraTransformResponse_default_instance_);
}
inline const ::uesynth::GetCameraTransformResponse& FrameResponse::camera_transform() const {
  // @@protoc_insertion_point(field_get:uesynth.FrameResponse.camera_transform)
  return _internal_camera_transform();
}
inline ::uesynth::GetCameraTransformResponse* FrameResponse::unsafe_arena_release_camera_transform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.FrameResponse.camera_transform)
  if (response_case() == kCameraTransform) {
    clear_has_response();
    ::uesynth::GetCameraTransformResponse* temp = _impl_.response_.camera_transform_;
    _impl_.response_.camera_transform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FrameResponse::unsafe_arena_set_allocated_camera_transform(::uesynth::GetCameraTransformResponse* camera_transform) {
  clear_response();
  if (camera_transform) {
    set_has_camera_transform();
    _impl_.response_.camera_transform_ = camera_transform;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.FrameResponse.camera_transform)
}
inline ::uesynth::GetCameraTransformResponse* FrameResponse::_internal_mutable_camera_transform() {
  if (response_case() != kCameraTransform) {
    clear_response();
    set_has_camera_transform();
    _impl_.response_.camera_transform_ = CreateMaybeMessage< ::uesynth::GetCameraTransformResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.camera_transform_;
}
inline ::uesynth::GetCameraTransformResponse* FrameResponse::mutable_camera_transform() {
  ::uesynth::GetCameraTransformResponse* _msg = _internal_mutable_camera_transform();
  // @@protoc_insertion_point(field_mutable:uesynth.FrameResponse.camera_transform)
  return _msg;
}

// .uesynth.ImageResponse image_response = 4;
inline bool FrameResponse::has_image_response() const {
  return response_case() == kImageResponse;
}
inline bool FrameResponse::_internal_has_image_response() const {
  return response_case() == kImageResponse;
}
inline void FrameResponse::set_has_image_response() {
  _impl_._oneof_case_[0] = kImageResponse;
}
inline void FrameResponse::clear_image_response() {
  if (response_case() == kImageResponse) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.image_response_;
    }
    clear_has_response();
  }
}
inline ::uesynth::ImageResponse* FrameResponse::release_image_response() {
  // @@protoc_insertion_point(field_release:uesynth.FrameResponse.image_response)
  if (response_case() == kImageResponse) {
    clear_has_response();
    ::uesynth::ImageResponse* temp = _impl_.response_.image_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.image_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::ImageResponse& FrameResponse::_internal_image_response() const {
  return response_case() == kImageResponse
      ? *_impl_.response_.image_response_
      : reinterpret_cast<::uesynth::ImageResponse&>(::uesynth::_ImageResponse_default_instance_);
}
inline const ::uesynth::ImageResponse& FrameResponse::image_response() const {
  // @@protoc_insertion_point(field_get:uesynth.FrameResponse.image_response)
  return _internal_image_response();
}
inline ::uesynth::ImageResponse* FrameResponse::unsafe_arena_release_image_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.FrameResponse.image_response)
  if (response_case() == kImageResponse) {
    clear_has_response();
    ::uesynth::ImageResponse* temp = _impl_.response_.image_response_;
    _impl_.response_.image_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FrameResponse::unsafe_arena_set_allocated_image_response(::uesynth::ImageResponse* image_response) {
  clear_response();
  if (image_response) {
    set_has_image_response();
    _impl_.response_.image_response_ = image_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.FrameResponse.image_response)
}
inline ::uesynth::ImageResponse* FrameResponse::_internal_mutable_image_response() {
  if (response_case() != kImageResponse) {
    clear_response();
    set_has_image_response();
    _impl_.response_.image_response_ = CreateMaybeMessage< ::uesynth::ImageResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.image_response_;
}
inline ::uesynth::ImageResponse* FrameResponse::mutable_image_response() {
  ::uesynth::ImageResponse* _msg = _internal_mutable_image_response();
  // @@protoc_insertion_point(field_mutable:uesynth.FrameResponse.image_response)
  return _msg;
}

// .uesynth.GetObjectTransformResponse object_transform = 5;
inline bool FrameResponse::has_object_transform() const {
  return response_case() == kObjectTransform;
}
inline bool FrameResponse::_internal_has_object_transform() const {
  return response_case() == kObjectTransform;
}
inline void FrameResponse::set_has_object_transform() {
  _impl_._oneof_case_[0] = kObjectTransform;
}
inline void FrameResponse::clear_object_transform() {
  if (response_case() == kObjectTransform) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.object_transform_;
    }
    clear_has_response();
  }
}
inline ::uesynth::GetObjectTransformResponse* FrameResponse::release_object_transform() {
  // @@protoc_insertion_point(field_release:uesynth.FrameResponse.object_transform)
  if (response_case() == kObjectTransform) {
    clear_has_response();
    ::uesynth::GetObjectTransformResponse* temp = _impl_.response_.object_transform_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.object_transform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::GetObjectTransformResponse& FrameResponse::_internal_object_transform() const {
  return response_case() == kObjectTransform
      ? *_impl_.response_.object_transform_
      : reinterpret_cast<::uesynth::GetObjectTransformResponse&>(::uesynth::_GetObjectTransformResponse_default_instance_);
}
inline const ::uesynth::GetObjectTransformResponse& FrameResponse::object_transform() const {
  // @@protoc_insertion_point(field_get:uesynth.FrameResponse.object_transform)
  return _internal_object_transform();
}
inline ::uesynth::GetObjectTransformResponse* FrameResponse::unsafe_arena_release_object_transform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.FrameResponse.object_transform)
  if (response_case() == kObjectTransform) {
    clear_has_response();
    ::uesynth::GetObjectTransformResponse* temp = _impl_.response_.object_transform_;
    _impl_.response_.object_transform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FrameResponse::unsafe_arena_set_allocated_object_transform(::uesynth::GetObjectTransformResponse* object_transform) {
  clear_response();
  if (object_transform) {
    set_has_object_transform();
    _impl_.response_.object_transform_ = object_transform;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.FrameResponse.object_transform)
}
inline ::uesynth::GetObjectTransformResponse* FrameResponse::_internal_mutable_object_transform() {
  if (response_case() != kObjectTransform) {
    clear_response();
    set_has_object_transform();
    _impl_.response_.object_transform_ = CreateMaybeMessage< ::uesynth::GetObjectTransformResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.object_transform_;
}
inline ::uesynth::GetObjectTransformResponse* FrameResponse::mutable_object_transform() {
  ::uesynth::GetObjectTransformResponse* _msg = _internal_mutable_object_transform();
  // @@protoc_insertion_point(field_mutable:uesynth.FrameResponse.object_transform)
  return _msg;
}

// .uesynth.ListObjectsResponse objects_list = 6;
inline bool FrameResponse::has_objects_list() const {
  return response_case() == kObjectsList;
}
inline bool FrameResponse::_internal_has_objects_list() const {
  return response_case() == kObjectsList;
}
inline void FrameResponse::set_has_objects_list() {
  _impl_._oneof_case_[0] = kObjectsList;
}
inline void FrameResponse::clear_objects_list() {
  if (response_case() == kObjectsList) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.objects_list_;
    }
    clear_has_response();
  }
}
inline ::uesynth::ListObjectsResponse* FrameResponse::release_objects_list() {
  // @@protoc_insertion_point(field_release:uesynth.FrameResponse.objects_list)
  if (response_case() == kObjectsList) {
    clear_has_response();
    ::uesynth::ListObjectsResponse* temp = _impl_.response_.objects_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.objects_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uesynth::ListObjectsResponse& FrameResponse::_internal_objects_list() const {
  return response_case() == kObjectsList
      ? *_impl_.response_.objects_list_
      : reinterpret_cast<::uesynth::ListObjectsResponse&>(::uesynth::_ListObjectsResponse_default_instance_);
}
inline const ::uesynth::ListObjectsResponse& FrameResponse::objects_list() const {
  // @@protoc_insertion_point(field_get:uesynth.FrameResponse.objects_list)
  return _internal_objects_list();
}
inline ::uesynth::ListObjectsResponse* FrameResponse::unsafe_arena_release_objects_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uesynth.FrameResponse.objects_list)
  if (response_case() == kObjectsList) {
    clear_has_response();
    ::uesynth::ListObjectsResponse* temp = _impl_.response_.objects_list_;
    _impl_.response_.objects_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FrameResponse::unsafe_arena_set_allocated_objects_list(::uesynth::ListObjectsResponse* objects_list) {
  clear_response();
  if (objects_list) {
    set_has_objects_list();
    _impl_.response_.objects_list_ = objects_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.FrameResponse.objects_list)
}
inline ::uesynth::ListObjectsResponse* FrameResponse::_internal_mutable_objects_list() {
  if (response_case() != kObjectsList) {
    clear_response();
    set_has_objects_list();
    _impl_.response_.objects_list_ = CreateMaybeMessage< ::uesynth::ListObjectsResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.objects_list_;
}
inline ::uesynth::ListObjectsResponse* FrameResponse::mutable_objects_list() {
  ::uesynth::ListObjectsResponse* _msg = _internal_mutable_objects_list();
  // @@protoc_insertion_point(field_mutable:uesynth.FrameResponse.objects_list)
  return _msg;
}

inline bool FrameResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void FrameResponse::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline FrameResponse::ResponseCase FrameResponse::response_case() const {
  return FrameResponse::ResponseCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Vector3

// float x = 1;
inline void Vector3::clear_x() {
  _impl_.x_ = 0;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:uesynth.Vector3.x)
  return _internal_x();
}
inline void Vector3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:uesynth.Vector3.x)
}
inline float Vector3::_internal_x() const {
  return _impl_.x_;
}
inline void Vector3::_internal_set_x(float value) {
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void Vector3::clear_y() {
  _impl_.y_ = 0;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:uesynth.Vector3.y)
  return _internal_y();
}
inline void Vector3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:uesynth.Vector3.y)
}
inline float Vector3::_internal_y() const {
  return _impl_.y_;
}
inline void Vector3::_internal_set_y(float value) {
  ;
  _impl_.y_ = value;
}

// float z = 3;
inline void Vector3::clear_z() {
  _impl_.z_ = 0;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:uesynth.Vector3.z)
  return _internal_z();
}
inline void Vector3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:uesynth.Vector3.z)
}
inline float Vector3::_internal_z() const {
  return _impl_.z_;
}
inline void Vector3::_internal_set_z(float value) {
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Rotator

// float pitch = 1;
inline void Rotator::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float Rotator::pitch() const {
  // @@protoc_insertion_point(field_get:uesynth.Rotator.pitch)
  return _internal_pitch();
}
inline void Rotator::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:uesynth.Rotator.pitch)
}
inline float Rotator::_internal_pitch() const {
  return _impl_.pitch_;
}
inline void Rotator::_internal_set_pitch(float value) {
  ;
  _impl_.pitch_ = value;
}

// float yaw = 2;
inline void Rotator::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float Rotator::yaw() const {
  // @@protoc_insertion_point(field_get:uesynth.Rotator.yaw)
  return _internal_yaw();
}
inline void Rotator::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:uesynth.Rotator.yaw)
}
inline float Rotator::_internal_yaw() const {
  return _impl_.yaw_;
}
inline void Rotator::_internal_set_yaw(float value) {
  ;
  _impl_.yaw_ = value;
}

// float roll = 3;
inline void Rotator::clear_roll() {
  _impl_.roll_ = 0;
}
inline float Rotator::roll() const {
  // @@protoc_insertion_point(field_get:uesynth.Rotator.roll)
  return _internal_roll();
}
inline void Rotator::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:uesynth.Rotator.roll)
}
inline float Rotator::_internal_roll() const {
  return _impl_.roll_;
}
inline void Rotator::_internal_set_roll(float value) {
  ;
  _impl_.roll_ = value;
}

// -------------------------------------------------------------------

// Transform

// .uesynth.Vector3 location = 1;
inline bool Transform::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline void Transform::clear_location() {
  if (_impl_.location_ != nullptr) _impl_.location_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::uesynth::Vector3& Transform::_internal_location() const {
  const ::uesynth::Vector3* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::uesynth::Vector3&>(
      ::uesynth::_Vector3_default_instance_);
}
inline const ::uesynth::Vector3& Transform::location() const {
  // @@protoc_insertion_point(field_get:uesynth.Transform.location)
  return _internal_location();
}
inline void Transform::unsafe_arena_set_allocated_location(
    ::uesynth::Vector3* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.Transform.location)
}
inline ::uesynth::Vector3* Transform::release_location() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uesynth::Vector3* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uesynth::Vector3* Transform::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:uesynth.Transform.location)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uesynth::Vector3* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::uesynth::Vector3* Transform::_internal_mutable_location() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::uesynth::Vector3>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::uesynth::Vector3* Transform::mutable_location() {
  ::uesynth::Vector3* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:uesynth.Transform.location)
  return _msg;
}
inline void Transform::set_allocated_location(::uesynth::Vector3* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:uesynth.Transform.location)
}

// .uesynth.Rotator rotation = 2;
inline bool Transform::has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void Transform::clear_rotation() {
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::uesynth::Rotator& Transform::_internal_rotation() const {
  const ::uesynth::Rotator* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::uesynth::Rotator&>(
      ::uesynth::_Rotator_default_instance_);
}
inline const ::uesynth::Rotator& Transform::rotation() const {
  // @@protoc_insertion_point(field_get:uesynth.Transform.rotation)
  return _internal_rotation();
}
inline void Transform::unsafe_arena_set_allocated_rotation(
    ::uesynth::Rotator* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = rotation;
  if (rotation) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.Transform.rotation)
}
inline ::uesynth::Rotator* Transform::release_rotation() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::uesynth::Rotator* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uesynth::Rotator* Transform::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:uesynth.Transform.rotation)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::uesynth::Rotator* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::uesynth::Rotator* Transform::_internal_mutable_rotation() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::uesynth::Rotator>(GetArenaForAllocation());
    _impl_.rotation_ = p;
  }
  return _impl_.rotation_;
}
inline ::uesynth::Rotator* Transform::mutable_rotation() {
  ::uesynth::Rotator* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:uesynth.Transform.rotation)
  return _msg;
}
inline void Transform::set_allocated_rotation(::uesynth::Rotator* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:uesynth.Transform.rotation)
}

// .uesynth.Vector3 scale = 3;
inline bool Transform::has_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scale_ != nullptr);
  return value;
}
inline void Transform::clear_scale() {
  if (_impl_.scale_ != nullptr) _impl_.scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::uesynth::Vector3& Transform::_internal_scale() const {
  const ::uesynth::Vector3* p = _impl_.scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::uesynth::Vector3&>(
      ::uesynth::_Vector3_default_instance_);
}
inline const ::uesynth::Vector3& Transform::scale() const {
  // @@protoc_insertion_point(field_get:uesynth.Transform.scale)
  return _internal_scale();
}
inline void Transform::unsafe_arena_set_allocated_scale(
    ::uesynth::Vector3* scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scale_);
  }
  _impl_.scale_ = scale;
  if (scale) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.Transform.scale)
}
inline ::uesynth::Vector3* Transform::release_scale() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::uesynth::Vector3* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uesynth::Vector3* Transform::unsafe_arena_release_scale() {
  // @@protoc_insertion_point(field_release:uesynth.Transform.scale)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::uesynth::Vector3* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
  return temp;
}
inline ::uesynth::Vector3* Transform::_internal_mutable_scale() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::uesynth::Vector3>(GetArenaForAllocation());
    _impl_.scale_ = p;
  }
  return _impl_.scale_;
}
inline ::uesynth::Vector3* Transform::mutable_scale() {
  ::uesynth::Vector3* _msg = _internal_mutable_scale();
  // @@protoc_insertion_point(field_mutable:uesynth.Transform.scale)
  return _msg;
}
inline void Transform::set_allocated_scale(::uesynth::Vector3* scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.scale_;
  }
  if (scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scale);
    if (message_arena != submessage_arena) {
      scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scale, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.scale_ = scale;
  // @@protoc_insertion_point(field_set_allocated:uesynth.Transform.scale)
}

// -------------------------------------------------------------------

// CommandResponse

// bool success = 1;
inline void CommandResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool CommandResponse::success() const {
  // @@protoc_insertion_point(field_get:uesynth.CommandResponse.success)
  return _internal_success();
}
inline void CommandResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:uesynth.CommandResponse.success)
}
inline bool CommandResponse::_internal_success() const {
  return _impl_.success_;
}
inline void CommandResponse::_internal_set_success(bool value) {
  ;
  _impl_.success_ = value;
}

// string message = 2;
inline void CommandResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& CommandResponse::message() const {
  // @@protoc_insertion_point(field_get:uesynth.CommandResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.CommandResponse.message)
}
inline std::string* CommandResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:uesynth.CommandResponse.message)
  return _s;
}
inline const std::string& CommandResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void CommandResponse::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* CommandResponse::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* CommandResponse::release_message() {
  // @@protoc_insertion_point(field_release:uesynth.CommandResponse.message)
  return _impl_.message_.Release();
}
inline void CommandResponse::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.CommandResponse.message)
}

// -------------------------------------------------------------------

// SetCameraTransformRequest

// string camera_name = 1;
inline void SetCameraTransformRequest::clear_camera_name() {
  _impl_.camera_name_.ClearToEmpty();
}
inline const std::string& SetCameraTransformRequest::camera_name() const {
  // @@protoc_insertion_point(field_get:uesynth.SetCameraTransformRequest.camera_name)
  return _internal_camera_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetCameraTransformRequest::set_camera_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.camera_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.SetCameraTransformRequest.camera_name)
}
inline std::string* SetCameraTransformRequest::mutable_camera_name() {
  std::string* _s = _internal_mutable_camera_name();
  // @@protoc_insertion_point(field_mutable:uesynth.SetCameraTransformRequest.camera_name)
  return _s;
}
inline const std::string& SetCameraTransformRequest::_internal_camera_name() const {
  return _impl_.camera_name_.Get();
}
inline void SetCameraTransformRequest::_internal_set_camera_name(const std::string& value) {
  ;


  _impl_.camera_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SetCameraTransformRequest::_internal_mutable_camera_name() {
  ;
  return _impl_.camera_name_.Mutable( GetArenaForAllocation());
}
inline std::string* SetCameraTransformRequest::release_camera_name() {
  // @@protoc_insertion_point(field_release:uesynth.SetCameraTransformRequest.camera_name)
  return _impl_.camera_name_.Release();
}
inline void SetCameraTransformRequest::set_allocated_camera_name(std::string* value) {
  _impl_.camera_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.camera_name_.IsDefault()) {
          _impl_.camera_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.SetCameraTransformRequest.camera_name)
}

// .uesynth.Transform transform = 2;
inline bool SetCameraTransformRequest::has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline void SetCameraTransformRequest::clear_transform() {
  if (_impl_.transform_ != nullptr) _impl_.transform_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::uesynth::Transform& SetCameraTransformRequest::_internal_transform() const {
  const ::uesynth::Transform* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::uesynth::Transform&>(
      ::uesynth::_Transform_default_instance_);
}
inline const ::uesynth::Transform& SetCameraTransformRequest::transform() const {
  // @@protoc_insertion_point(field_get:uesynth.SetCameraTransformRequest.transform)
  return _internal_transform();
}
inline void SetCameraTransformRequest::unsafe_arena_set_allocated_transform(
    ::uesynth::Transform* transform) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = transform;
  if (transform) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.SetCameraTransformRequest.transform)
}
inline ::uesynth::Transform* SetCameraTransformRequest::release_transform() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uesynth::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uesynth::Transform* SetCameraTransformRequest::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_release:uesynth.SetCameraTransformRequest.transform)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uesynth::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::uesynth::Transform* SetCameraTransformRequest::_internal_mutable_transform() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::uesynth::Transform>(GetArenaForAllocation());
    _impl_.transform_ = p;
  }
  return _impl_.transform_;
}
inline ::uesynth::Transform* SetCameraTransformRequest::mutable_transform() {
  ::uesynth::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:uesynth.SetCameraTransformRequest.transform)
  return _msg;
}
inline void SetCameraTransformRequest::set_allocated_transform(::uesynth::Transform* transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.transform_;
  }
  if (transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:uesynth.SetCameraTransformRequest.transform)
}

// -------------------------------------------------------------------

// GetCameraTransformRequest

// string camera_name = 1;
inline void GetCameraTransformRequest::clear_camera_name() {
  _impl_.camera_name_.ClearToEmpty();
}
inline const std::string& GetCameraTransformRequest::camera_name() const {
  // @@protoc_insertion_point(field_get:uesynth.GetCameraTransformRequest.camera_name)
  return _internal_camera_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetCameraTransformRequest::set_camera_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.camera_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.GetCameraTransformRequest.camera_name)
}
inline std::string* GetCameraTransformRequest::mutable_camera_name() {
  std::string* _s = _internal_mutable_camera_name();
  // @@protoc_insertion_point(field_mutable:uesynth.GetCameraTransformRequest.camera_name)
  return _s;
}
inline const std::string& GetCameraTransformRequest::_internal_camera_name() const {
  return _impl_.camera_name_.Get();
}
inline void GetCameraTransformRequest::_internal_set_camera_name(const std::string& value) {
  ;


  _impl_.camera_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetCameraTransformRequest::_internal_mutable_camera_name() {
  ;
  return _impl_.camera_name_.Mutable( GetArenaForAllocation());
}
inline std::string* GetCameraTransformRequest::release_camera_name() {
  // @@protoc_insertion_point(field_release:uesynth.GetCameraTransformRequest.camera_name)
  return _impl_.camera_name_.Release();
}
inline void GetCameraTransformRequest::set_allocated_camera_name(std::string* value) {
  _impl_.camera_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.camera_name_.IsDefault()) {
          _impl_.camera_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.GetCameraTransformRequest.camera_name)
}

// -------------------------------------------------------------------

// GetCameraTransformResponse

// .uesynth.Transform transform = 1;
inline bool GetCameraTransformResponse::has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline void GetCameraTransformResponse::clear_transform() {
  if (_impl_.transform_ != nullptr) _impl_.transform_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::uesynth::Transform& GetCameraTransformResponse::_internal_transform() const {
  const ::uesynth::Transform* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::uesynth::Transform&>(
      ::uesynth::_Transform_default_instance_);
}
inline const ::uesynth::Transform& GetCameraTransformResponse::transform() const {
  // @@protoc_insertion_point(field_get:uesynth.GetCameraTransformResponse.transform)
  return _internal_transform();
}
inline void GetCameraTransformResponse::unsafe_arena_set_allocated_transform(
    ::uesynth::Transform* transform) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = transform;
  if (transform) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.GetCameraTransformResponse.transform)
}
inline ::uesynth::Transform* GetCameraTransformResponse::release_transform() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uesynth::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uesynth::Transform* GetCameraTransformResponse::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_release:uesynth.GetCameraTransformResponse.transform)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uesynth::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::uesynth::Transform* GetCameraTransformResponse::_internal_mutable_transform() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::uesynth::Transform>(GetArenaForAllocation());
    _impl_.transform_ = p;
  }
  return _impl_.transform_;
}
inline ::uesynth::Transform* GetCameraTransformResponse::mutable_transform() {
  ::uesynth::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:uesynth.GetCameraTransformResponse.transform)
  return _msg;
}
inline void GetCameraTransformResponse::set_allocated_transform(::uesynth::Transform* transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.transform_;
  }
  if (transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:uesynth.GetCameraTransformResponse.transform)
}

// bool success = 2;
inline void GetCameraTransformResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool GetCameraTransformResponse::success() const {
  // @@protoc_insertion_point(field_get:uesynth.GetCameraTransformResponse.success)
  return _internal_success();
}
inline void GetCameraTransformResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:uesynth.GetCameraTransformResponse.success)
}
inline bool GetCameraTransformResponse::_internal_success() const {
  return _impl_.success_;
}
inline void GetCameraTransformResponse::_internal_set_success(bool value) {
  ;
  _impl_.success_ = value;
}

// string message = 3;
inline void GetCameraTransformResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetCameraTransformResponse::message() const {
  // @@protoc_insertion_point(field_get:uesynth.GetCameraTransformResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetCameraTransformResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.GetCameraTransformResponse.message)
}
inline std::string* GetCameraTransformResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:uesynth.GetCameraTransformResponse.message)
  return _s;
}
inline const std::string& GetCameraTransformResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetCameraTransformResponse::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetCameraTransformResponse::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* GetCameraTransformResponse::release_message() {
  // @@protoc_insertion_point(field_release:uesynth.GetCameraTransformResponse.message)
  return _impl_.message_.Release();
}
inline void GetCameraTransformResponse::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.GetCameraTransformResponse.message)
}

// -------------------------------------------------------------------

// CaptureRequest

// string camera_name = 1;
inline void CaptureRequest::clear_camera_name() {
  _impl_.camera_name_.ClearToEmpty();
}
inline const std::string& CaptureRequest::camera_name() const {
  // @@protoc_insertion_point(field_get:uesynth.CaptureRequest.camera_name)
  return _internal_camera_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CaptureRequest::set_camera_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.camera_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.CaptureRequest.camera_name)
}
inline std::string* CaptureRequest::mutable_camera_name() {
  std::string* _s = _internal_mutable_camera_name();
  // @@protoc_insertion_point(field_mutable:uesynth.CaptureRequest.camera_name)
  return _s;
}
inline const std::string& CaptureRequest::_internal_camera_name() const {
  return _impl_.camera_name_.Get();
}
inline void CaptureRequest::_internal_set_camera_name(const std::string& value) {
  ;


  _impl_.camera_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CaptureRequest::_internal_mutable_camera_name() {
  ;
  return _impl_.camera_name_.Mutable( GetArenaForAllocation());
}
inline std::string* CaptureRequest::release_camera_name() {
  // @@protoc_insertion_point(field_release:uesynth.CaptureRequest.camera_name)
  return _impl_.camera_name_.Release();
}
inline void CaptureRequest::set_allocated_camera_name(std::string* value) {
  _impl_.camera_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.camera_name_.IsDefault()) {
          _impl_.camera_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.CaptureRequest.camera_name)
}

// uint32 width = 2;
inline void CaptureRequest::clear_width() {
  _impl_.width_ = 0u;
}
inline ::uint32_t CaptureRequest::width() const {
  // @@protoc_insertion_point(field_get:uesynth.CaptureRequest.width)
  return _internal_width();
}
inline void CaptureRequest::set_width(::uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:uesynth.CaptureRequest.width)
}
inline ::uint32_t CaptureRequest::_internal_width() const {
  return _impl_.width_;
}
inline void CaptureRequest::_internal_set_width(::uint32_t value) {
  ;
  _impl_.width_ = value;
}

// uint32 height = 3;
inline void CaptureRequest::clear_height() {
  _impl_.height_ = 0u;
}
inline ::uint32_t CaptureRequest::height() const {
  // @@protoc_insertion_point(field_get:uesynth.CaptureRequest.height)
  return _internal_height();
}
inline void CaptureRequest::set_height(::uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:uesynth.CaptureRequest.height)
}
inline ::uint32_t CaptureRequest::_internal_height() const {
  return _impl_.height_;
}
inline void CaptureRequest::_internal_set_height(::uint32_t value) {
  ;
  _impl_.height_ = value;
}

// -------------------------------------------------------------------

// ImageResponse

// bytes image_data = 1;
inline void ImageResponse::clear_image_data() {
  _impl_.image_data_.ClearToEmpty();
}
inline const std::string& ImageResponse::image_data() const {
  // @@protoc_insertion_point(field_get:uesynth.ImageResponse.image_data)
  return _internal_image_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImageResponse::set_image_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.image_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.ImageResponse.image_data)
}
inline std::string* ImageResponse::mutable_image_data() {
  std::string* _s = _internal_mutable_image_data();
  // @@protoc_insertion_point(field_mutable:uesynth.ImageResponse.image_data)
  return _s;
}
inline const std::string& ImageResponse::_internal_image_data() const {
  return _impl_.image_data_.Get();
}
inline void ImageResponse::_internal_set_image_data(const std::string& value) {
  ;


  _impl_.image_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageResponse::_internal_mutable_image_data() {
  ;
  return _impl_.image_data_.Mutable( GetArenaForAllocation());
}
inline std::string* ImageResponse::release_image_data() {
  // @@protoc_insertion_point(field_release:uesynth.ImageResponse.image_data)
  return _impl_.image_data_.Release();
}
inline void ImageResponse::set_allocated_image_data(std::string* value) {
  _impl_.image_data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.image_data_.IsDefault()) {
          _impl_.image_data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.ImageResponse.image_data)
}

// uint32 width = 2;
inline void ImageResponse::clear_width() {
  _impl_.width_ = 0u;
}
inline ::uint32_t ImageResponse::width() const {
  // @@protoc_insertion_point(field_get:uesynth.ImageResponse.width)
  return _internal_width();
}
inline void ImageResponse::set_width(::uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:uesynth.ImageResponse.width)
}
inline ::uint32_t ImageResponse::_internal_width() const {
  return _impl_.width_;
}
inline void ImageResponse::_internal_set_width(::uint32_t value) {
  ;
  _impl_.width_ = value;
}

// uint32 height = 3;
inline void ImageResponse::clear_height() {
  _impl_.height_ = 0u;
}
inline ::uint32_t ImageResponse::height() const {
  // @@protoc_insertion_point(field_get:uesynth.ImageResponse.height)
  return _internal_height();
}
inline void ImageResponse::set_height(::uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:uesynth.ImageResponse.height)
}
inline ::uint32_t ImageResponse::_internal_height() const {
  return _impl_.height_;
}
inline void ImageResponse::_internal_set_height(::uint32_t value) {
  ;
  _impl_.height_ = value;
}

// string format = 4;
inline void ImageResponse::clear_format() {
  _impl_.format_.ClearToEmpty();
}
inline const std::string& ImageResponse::format() const {
  // @@protoc_insertion_point(field_get:uesynth.ImageResponse.format)
  return _internal_format();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImageResponse::set_format(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.format_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.ImageResponse.format)
}
inline std::string* ImageResponse::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:uesynth.ImageResponse.format)
  return _s;
}
inline const std::string& ImageResponse::_internal_format() const {
  return _impl_.format_.Get();
}
inline void ImageResponse::_internal_set_format(const std::string& value) {
  ;


  _impl_.format_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageResponse::_internal_mutable_format() {
  ;
  return _impl_.format_.Mutable( GetArenaForAllocation());
}
inline std::string* ImageResponse::release_format() {
  // @@protoc_insertion_point(field_release:uesynth.ImageResponse.format)
  return _impl_.format_.Release();
}
inline void ImageResponse::set_allocated_format(std::string* value) {
  _impl_.format_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.format_.IsDefault()) {
          _impl_.format_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.ImageResponse.format)
}

// -------------------------------------------------------------------

// SetObjectTransformRequest

// string object_name = 1;
inline void SetObjectTransformRequest::clear_object_name() {
  _impl_.object_name_.ClearToEmpty();
}
inline const std::string& SetObjectTransformRequest::object_name() const {
  // @@protoc_insertion_point(field_get:uesynth.SetObjectTransformRequest.object_name)
  return _internal_object_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetObjectTransformRequest::set_object_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.object_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.SetObjectTransformRequest.object_name)
}
inline std::string* SetObjectTransformRequest::mutable_object_name() {
  std::string* _s = _internal_mutable_object_name();
  // @@protoc_insertion_point(field_mutable:uesynth.SetObjectTransformRequest.object_name)
  return _s;
}
inline const std::string& SetObjectTransformRequest::_internal_object_name() const {
  return _impl_.object_name_.Get();
}
inline void SetObjectTransformRequest::_internal_set_object_name(const std::string& value) {
  ;


  _impl_.object_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SetObjectTransformRequest::_internal_mutable_object_name() {
  ;
  return _impl_.object_name_.Mutable( GetArenaForAllocation());
}
inline std::string* SetObjectTransformRequest::release_object_name() {
  // @@protoc_insertion_point(field_release:uesynth.SetObjectTransformRequest.object_name)
  return _impl_.object_name_.Release();
}
inline void SetObjectTransformRequest::set_allocated_object_name(std::string* value) {
  _impl_.object_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.object_name_.IsDefault()) {
          _impl_.object_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.SetObjectTransformRequest.object_name)
}

// .uesynth.Transform transform = 2;
inline bool SetObjectTransformRequest::has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline void SetObjectTransformRequest::clear_transform() {
  if (_impl_.transform_ != nullptr) _impl_.transform_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::uesynth::Transform& SetObjectTransformRequest::_internal_transform() const {
  const ::uesynth::Transform* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::uesynth::Transform&>(
      ::uesynth::_Transform_default_instance_);
}
inline const ::uesynth::Transform& SetObjectTransformRequest::transform() const {
  // @@protoc_insertion_point(field_get:uesynth.SetObjectTransformRequest.transform)
  return _internal_transform();
}
inline void SetObjectTransformRequest::unsafe_arena_set_allocated_transform(
    ::uesynth::Transform* transform) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = transform;
  if (transform) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.SetObjectTransformRequest.transform)
}
inline ::uesynth::Transform* SetObjectTransformRequest::release_transform() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uesynth::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uesynth::Transform* SetObjectTransformRequest::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_release:uesynth.SetObjectTransformRequest.transform)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uesynth::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::uesynth::Transform* SetObjectTransformRequest::_internal_mutable_transform() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::uesynth::Transform>(GetArenaForAllocation());
    _impl_.transform_ = p;
  }
  return _impl_.transform_;
}
inline ::uesynth::Transform* SetObjectTransformRequest::mutable_transform() {
  ::uesynth::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:uesynth.SetObjectTransformRequest.transform)
  return _msg;
}
inline void SetObjectTransformRequest::set_allocated_transform(::uesynth::Transform* transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.transform_;
  }
  if (transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:uesynth.SetObjectTransformRequest.transform)
}

// -------------------------------------------------------------------

// GetObjectTransformRequest

// string object_name = 1;
inline void GetObjectTransformRequest::clear_object_name() {
  _impl_.object_name_.ClearToEmpty();
}
inline const std::string& GetObjectTransformRequest::object_name() const {
  // @@protoc_insertion_point(field_get:uesynth.GetObjectTransformRequest.object_name)
  return _internal_object_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetObjectTransformRequest::set_object_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.object_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.GetObjectTransformRequest.object_name)
}
inline std::string* GetObjectTransformRequest::mutable_object_name() {
  std::string* _s = _internal_mutable_object_name();
  // @@protoc_insertion_point(field_mutable:uesynth.GetObjectTransformRequest.object_name)
  return _s;
}
inline const std::string& GetObjectTransformRequest::_internal_object_name() const {
  return _impl_.object_name_.Get();
}
inline void GetObjectTransformRequest::_internal_set_object_name(const std::string& value) {
  ;


  _impl_.object_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetObjectTransformRequest::_internal_mutable_object_name() {
  ;
  return _impl_.object_name_.Mutable( GetArenaForAllocation());
}
inline std::string* GetObjectTransformRequest::release_object_name() {
  // @@protoc_insertion_point(field_release:uesynth.GetObjectTransformRequest.object_name)
  return _impl_.object_name_.Release();
}
inline void GetObjectTransformRequest::set_allocated_object_name(std::string* value) {
  _impl_.object_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.object_name_.IsDefault()) {
          _impl_.object_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.GetObjectTransformRequest.object_name)
}

// -------------------------------------------------------------------

// GetObjectTransformResponse

// .uesynth.Transform transform = 1;
inline bool GetObjectTransformResponse::has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline void GetObjectTransformResponse::clear_transform() {
  if (_impl_.transform_ != nullptr) _impl_.transform_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::uesynth::Transform& GetObjectTransformResponse::_internal_transform() const {
  const ::uesynth::Transform* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::uesynth::Transform&>(
      ::uesynth::_Transform_default_instance_);
}
inline const ::uesynth::Transform& GetObjectTransformResponse::transform() const {
  // @@protoc_insertion_point(field_get:uesynth.GetObjectTransformResponse.transform)
  return _internal_transform();
}
inline void GetObjectTransformResponse::unsafe_arena_set_allocated_transform(
    ::uesynth::Transform* transform) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = transform;
  if (transform) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.GetObjectTransformResponse.transform)
}
inline ::uesynth::Transform* GetObjectTransformResponse::release_transform() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uesynth::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uesynth::Transform* GetObjectTransformResponse::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_release:uesynth.GetObjectTransformResponse.transform)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uesynth::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::uesynth::Transform* GetObjectTransformResponse::_internal_mutable_transform() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::uesynth::Transform>(GetArenaForAllocation());
    _impl_.transform_ = p;
  }
  return _impl_.transform_;
}
inline ::uesynth::Transform* GetObjectTransformResponse::mutable_transform() {
  ::uesynth::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:uesynth.GetObjectTransformResponse.transform)
  return _msg;
}
inline void GetObjectTransformResponse::set_allocated_transform(::uesynth::Transform* transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.transform_;
  }
  if (transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:uesynth.GetObjectTransformResponse.transform)
}

// bool success = 2;
inline void GetObjectTransformResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool GetObjectTransformResponse::success() const {
  // @@protoc_insertion_point(field_get:uesynth.GetObjectTransformResponse.success)
  return _internal_success();
}
inline void GetObjectTransformResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:uesynth.GetObjectTransformResponse.success)
}
inline bool GetObjectTransformResponse::_internal_success() const {
  return _impl_.success_;
}
inline void GetObjectTransformResponse::_internal_set_success(bool value) {
  ;
  _impl_.success_ = value;
}

// string message = 3;
inline void GetObjectTransformResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetObjectTransformResponse::message() const {
  // @@protoc_insertion_point(field_get:uesynth.GetObjectTransformResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetObjectTransformResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.GetObjectTransformResponse.message)
}
inline std::string* GetObjectTransformResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:uesynth.GetObjectTransformResponse.message)
  return _s;
}
inline const std::string& GetObjectTransformResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetObjectTransformResponse::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetObjectTransformResponse::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* GetObjectTransformResponse::release_message() {
  // @@protoc_insertion_point(field_release:uesynth.GetObjectTransformResponse.message)
  return _impl_.message_.Release();
}
inline void GetObjectTransformResponse::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.GetObjectTransformResponse.message)
}

// -------------------------------------------------------------------

// CreateCameraRequest

// string camera_name = 1;
inline void CreateCameraRequest::clear_camera_name() {
  _impl_.camera_name_.ClearToEmpty();
}
inline const std::string& CreateCameraRequest::camera_name() const {
  // @@protoc_insertion_point(field_get:uesynth.CreateCameraRequest.camera_name)
  return _internal_camera_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateCameraRequest::set_camera_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.camera_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.CreateCameraRequest.camera_name)
}
inline std::string* CreateCameraRequest::mutable_camera_name() {
  std::string* _s = _internal_mutable_camera_name();
  // @@protoc_insertion_point(field_mutable:uesynth.CreateCameraRequest.camera_name)
  return _s;
}
inline const std::string& CreateCameraRequest::_internal_camera_name() const {
  return _impl_.camera_name_.Get();
}
inline void CreateCameraRequest::_internal_set_camera_name(const std::string& value) {
  ;


  _impl_.camera_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateCameraRequest::_internal_mutable_camera_name() {
  ;
  return _impl_.camera_name_.Mutable( GetArenaForAllocation());
}
inline std::string* CreateCameraRequest::release_camera_name() {
  // @@protoc_insertion_point(field_release:uesynth.CreateCameraRequest.camera_name)
  return _impl_.camera_name_.Release();
}
inline void CreateCameraRequest::set_allocated_camera_name(std::string* value) {
  _impl_.camera_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.camera_name_.IsDefault()) {
          _impl_.camera_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.CreateCameraRequest.camera_name)
}

// .uesynth.Transform initial_transform = 2;
inline bool CreateCameraRequest::has_initial_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.initial_transform_ != nullptr);
  return value;
}
inline void CreateCameraRequest::clear_initial_transform() {
  if (_impl_.initial_transform_ != nullptr) _impl_.initial_transform_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::uesynth::Transform& CreateCameraRequest::_internal_initial_transform() const {
  const ::uesynth::Transform* p = _impl_.initial_transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::uesynth::Transform&>(
      ::uesynth::_Transform_default_instance_);
}
inline const ::uesynth::Transform& CreateCameraRequest::initial_transform() const {
  // @@protoc_insertion_point(field_get:uesynth.CreateCameraRequest.initial_transform)
  return _internal_initial_transform();
}
inline void CreateCameraRequest::unsafe_arena_set_allocated_initial_transform(
    ::uesynth::Transform* initial_transform) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.initial_transform_);
  }
  _impl_.initial_transform_ = initial_transform;
  if (initial_transform) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.CreateCameraRequest.initial_transform)
}
inline ::uesynth::Transform* CreateCameraRequest::release_initial_transform() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uesynth::Transform* temp = _impl_.initial_transform_;
  _impl_.initial_transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uesynth::Transform* CreateCameraRequest::unsafe_arena_release_initial_transform() {
  // @@protoc_insertion_point(field_release:uesynth.CreateCameraRequest.initial_transform)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uesynth::Transform* temp = _impl_.initial_transform_;
  _impl_.initial_transform_ = nullptr;
  return temp;
}
inline ::uesynth::Transform* CreateCameraRequest::_internal_mutable_initial_transform() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.initial_transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::uesynth::Transform>(GetArenaForAllocation());
    _impl_.initial_transform_ = p;
  }
  return _impl_.initial_transform_;
}
inline ::uesynth::Transform* CreateCameraRequest::mutable_initial_transform() {
  ::uesynth::Transform* _msg = _internal_mutable_initial_transform();
  // @@protoc_insertion_point(field_mutable:uesynth.CreateCameraRequest.initial_transform)
  return _msg;
}
inline void CreateCameraRequest::set_allocated_initial_transform(::uesynth::Transform* initial_transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.initial_transform_;
  }
  if (initial_transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(initial_transform);
    if (message_arena != submessage_arena) {
      initial_transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial_transform, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.initial_transform_ = initial_transform;
  // @@protoc_insertion_point(field_set_allocated:uesynth.CreateCameraRequest.initial_transform)
}

// -------------------------------------------------------------------

// DestroyCameraRequest

// string camera_name = 1;
inline void DestroyCameraRequest::clear_camera_name() {
  _impl_.camera_name_.ClearToEmpty();
}
inline const std::string& DestroyCameraRequest::camera_name() const {
  // @@protoc_insertion_point(field_get:uesynth.DestroyCameraRequest.camera_name)
  return _internal_camera_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DestroyCameraRequest::set_camera_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.camera_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.DestroyCameraRequest.camera_name)
}
inline std::string* DestroyCameraRequest::mutable_camera_name() {
  std::string* _s = _internal_mutable_camera_name();
  // @@protoc_insertion_point(field_mutable:uesynth.DestroyCameraRequest.camera_name)
  return _s;
}
inline const std::string& DestroyCameraRequest::_internal_camera_name() const {
  return _impl_.camera_name_.Get();
}
inline void DestroyCameraRequest::_internal_set_camera_name(const std::string& value) {
  ;


  _impl_.camera_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DestroyCameraRequest::_internal_mutable_camera_name() {
  ;
  return _impl_.camera_name_.Mutable( GetArenaForAllocation());
}
inline std::string* DestroyCameraRequest::release_camera_name() {
  // @@protoc_insertion_point(field_release:uesynth.DestroyCameraRequest.camera_name)
  return _impl_.camera_name_.Release();
}
inline void DestroyCameraRequest::set_allocated_camera_name(std::string* value) {
  _impl_.camera_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.camera_name_.IsDefault()) {
          _impl_.camera_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.DestroyCameraRequest.camera_name)
}

// -------------------------------------------------------------------

// SetResolutionRequest

// string camera_name = 1;
inline void SetResolutionRequest::clear_camera_name() {
  _impl_.camera_name_.ClearToEmpty();
}
inline const std::string& SetResolutionRequest::camera_name() const {
  // @@protoc_insertion_point(field_get:uesynth.SetResolutionRequest.camera_name)
  return _internal_camera_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetResolutionRequest::set_camera_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.camera_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.SetResolutionRequest.camera_name)
}
inline std::string* SetResolutionRequest::mutable_camera_name() {
  std::string* _s = _internal_mutable_camera_name();
  // @@protoc_insertion_point(field_mutable:uesynth.SetResolutionRequest.camera_name)
  return _s;
}
inline const std::string& SetResolutionRequest::_internal_camera_name() const {
  return _impl_.camera_name_.Get();
}
inline void SetResolutionRequest::_internal_set_camera_name(const std::string& value) {
  ;


  _impl_.camera_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SetResolutionRequest::_internal_mutable_camera_name() {
  ;
  return _impl_.camera_name_.Mutable( GetArenaForAllocation());
}
inline std::string* SetResolutionRequest::release_camera_name() {
  // @@protoc_insertion_point(field_release:uesynth.SetResolutionRequest.camera_name)
  return _impl_.camera_name_.Release();
}
inline void SetResolutionRequest::set_allocated_camera_name(std::string* value) {
  _impl_.camera_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.camera_name_.IsDefault()) {
          _impl_.camera_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.SetResolutionRequest.camera_name)
}

// uint32 width = 2;
inline void SetResolutionRequest::clear_width() {
  _impl_.width_ = 0u;
}
inline ::uint32_t SetResolutionRequest::width() const {
  // @@protoc_insertion_point(field_get:uesynth.SetResolutionRequest.width)
  return _internal_width();
}
inline void SetResolutionRequest::set_width(::uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:uesynth.SetResolutionRequest.width)
}
inline ::uint32_t SetResolutionRequest::_internal_width() const {
  return _impl_.width_;
}
inline void SetResolutionRequest::_internal_set_width(::uint32_t value) {
  ;
  _impl_.width_ = value;
}

// uint32 height = 3;
inline void SetResolutionRequest::clear_height() {
  _impl_.height_ = 0u;
}
inline ::uint32_t SetResolutionRequest::height() const {
  // @@protoc_insertion_point(field_get:uesynth.SetResolutionRequest.height)
  return _internal_height();
}
inline void SetResolutionRequest::set_height(::uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:uesynth.SetResolutionRequest.height)
}
inline ::uint32_t SetResolutionRequest::_internal_height() const {
  return _impl_.height_;
}
inline void SetResolutionRequest::_internal_set_height(::uint32_t value) {
  ;
  _impl_.height_ = value;
}

// -------------------------------------------------------------------

// ListObjectsResponse

// repeated string object_names = 1;
inline int ListObjectsResponse::_internal_object_names_size() const {
  return _impl_.object_names_.size();
}
inline int ListObjectsResponse::object_names_size() const {
  return _internal_object_names_size();
}
inline void ListObjectsResponse::clear_object_names() {
  _internal_mutable_object_names()->Clear();
}
inline std::string* ListObjectsResponse::add_object_names() {
  std::string* _s = _internal_add_object_names();
  // @@protoc_insertion_point(field_add_mutable:uesynth.ListObjectsResponse.object_names)
  return _s;
}
inline const std::string& ListObjectsResponse::object_names(int index) const {
  // @@protoc_insertion_point(field_get:uesynth.ListObjectsResponse.object_names)
  return _internal_object_names(index);
}
inline std::string* ListObjectsResponse::mutable_object_names(int index) {
  // @@protoc_insertion_point(field_mutable:uesynth.ListObjectsResponse.object_names)
  return _internal_mutable_object_names()->Mutable(index);
}
inline void ListObjectsResponse::set_object_names(int index, const std::string& value) {
  _internal_mutable_object_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:uesynth.ListObjectsResponse.object_names)
}
inline void ListObjectsResponse::set_object_names(int index, std::string&& value) {
  _internal_mutable_object_names()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:uesynth.ListObjectsResponse.object_names)
}
inline void ListObjectsResponse::set_object_names(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_object_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:uesynth.ListObjectsResponse.object_names)
}
inline void ListObjectsResponse::set_object_names(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_object_names()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:uesynth.ListObjectsResponse.object_names)
}
inline void ListObjectsResponse::set_object_names(int index, absl::string_view value) {
  _internal_mutable_object_names()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:uesynth.ListObjectsResponse.object_names)
}
inline void ListObjectsResponse::add_object_names(const std::string& value) {
  _internal_mutable_object_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:uesynth.ListObjectsResponse.object_names)
}
inline void ListObjectsResponse::add_object_names(std::string&& value) {
  _internal_mutable_object_names()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:uesynth.ListObjectsResponse.object_names)
}
inline void ListObjectsResponse::add_object_names(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_object_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:uesynth.ListObjectsResponse.object_names)
}
inline void ListObjectsResponse::add_object_names(const char* value, std::size_t size) {
  _internal_mutable_object_names()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:uesynth.ListObjectsResponse.object_names)
}
inline void ListObjectsResponse::add_object_names(absl::string_view value) {
  _internal_mutable_object_names()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:uesynth.ListObjectsResponse.object_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListObjectsResponse::object_names() const {
  // @@protoc_insertion_point(field_list:uesynth.ListObjectsResponse.object_names)
  return _internal_object_names();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ListObjectsResponse::mutable_object_names() {
  // @@protoc_insertion_point(field_mutable_list:uesynth.ListObjectsResponse.object_names)
  return _internal_mutable_object_names();
}
inline const std::string& ListObjectsResponse::_internal_object_names(int index) const {
  return _internal_object_names().Get(index);
}
inline std::string* ListObjectsResponse::_internal_add_object_names() {
  return _internal_mutable_object_names()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListObjectsResponse::_internal_object_names() const {
  return _impl_.object_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListObjectsResponse::_internal_mutable_object_names() {
  return &_impl_.object_names_;
}

// -------------------------------------------------------------------

// SpawnObjectRequest

// string object_name = 1;
inline void SpawnObjectRequest::clear_object_name() {
  _impl_.object_name_.ClearToEmpty();
}
inline const std::string& SpawnObjectRequest::object_name() const {
  // @@protoc_insertion_point(field_get:uesynth.SpawnObjectRequest.object_name)
  return _internal_object_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpawnObjectRequest::set_object_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.object_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.SpawnObjectRequest.object_name)
}
inline std::string* SpawnObjectRequest::mutable_object_name() {
  std::string* _s = _internal_mutable_object_name();
  // @@protoc_insertion_point(field_mutable:uesynth.SpawnObjectRequest.object_name)
  return _s;
}
inline const std::string& SpawnObjectRequest::_internal_object_name() const {
  return _impl_.object_name_.Get();
}
inline void SpawnObjectRequest::_internal_set_object_name(const std::string& value) {
  ;


  _impl_.object_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SpawnObjectRequest::_internal_mutable_object_name() {
  ;
  return _impl_.object_name_.Mutable( GetArenaForAllocation());
}
inline std::string* SpawnObjectRequest::release_object_name() {
  // @@protoc_insertion_point(field_release:uesynth.SpawnObjectRequest.object_name)
  return _impl_.object_name_.Release();
}
inline void SpawnObjectRequest::set_allocated_object_name(std::string* value) {
  _impl_.object_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.object_name_.IsDefault()) {
          _impl_.object_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.SpawnObjectRequest.object_name)
}

// string asset_path = 2;
inline void SpawnObjectRequest::clear_asset_path() {
  _impl_.asset_path_.ClearToEmpty();
}
inline const std::string& SpawnObjectRequest::asset_path() const {
  // @@protoc_insertion_point(field_get:uesynth.SpawnObjectRequest.asset_path)
  return _internal_asset_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpawnObjectRequest::set_asset_path(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.asset_path_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.SpawnObjectRequest.asset_path)
}
inline std::string* SpawnObjectRequest::mutable_asset_path() {
  std::string* _s = _internal_mutable_asset_path();
  // @@protoc_insertion_point(field_mutable:uesynth.SpawnObjectRequest.asset_path)
  return _s;
}
inline const std::string& SpawnObjectRequest::_internal_asset_path() const {
  return _impl_.asset_path_.Get();
}
inline void SpawnObjectRequest::_internal_set_asset_path(const std::string& value) {
  ;


  _impl_.asset_path_.Set(value, GetArenaForAllocation());
}
inline std::string* SpawnObjectRequest::_internal_mutable_asset_path() {
  ;
  return _impl_.asset_path_.Mutable( GetArenaForAllocation());
}
inline std::string* SpawnObjectRequest::release_asset_path() {
  // @@protoc_insertion_point(field_release:uesynth.SpawnObjectRequest.asset_path)
  return _impl_.asset_path_.Release();
}
inline void SpawnObjectRequest::set_allocated_asset_path(std::string* value) {
  _impl_.asset_path_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.asset_path_.IsDefault()) {
          _impl_.asset_path_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.SpawnObjectRequest.asset_path)
}

// .uesynth.Transform initial_transform = 3;
inline bool SpawnObjectRequest::has_initial_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.initial_transform_ != nullptr);
  return value;
}
inline void SpawnObjectRequest::clear_initial_transform() {
  if (_impl_.initial_transform_ != nullptr) _impl_.initial_transform_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::uesynth::Transform& SpawnObjectRequest::_internal_initial_transform() const {
  const ::uesynth::Transform* p = _impl_.initial_transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::uesynth::Transform&>(
      ::uesynth::_Transform_default_instance_);
}
inline const ::uesynth::Transform& SpawnObjectRequest::initial_transform() const {
  // @@protoc_insertion_point(field_get:uesynth.SpawnObjectRequest.initial_transform)
  return _internal_initial_transform();
}
inline void SpawnObjectRequest::unsafe_arena_set_allocated_initial_transform(
    ::uesynth::Transform* initial_transform) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.initial_transform_);
  }
  _impl_.initial_transform_ = initial_transform;
  if (initial_transform) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.SpawnObjectRequest.initial_transform)
}
inline ::uesynth::Transform* SpawnObjectRequest::release_initial_transform() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uesynth::Transform* temp = _impl_.initial_transform_;
  _impl_.initial_transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uesynth::Transform* SpawnObjectRequest::unsafe_arena_release_initial_transform() {
  // @@protoc_insertion_point(field_release:uesynth.SpawnObjectRequest.initial_transform)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uesynth::Transform* temp = _impl_.initial_transform_;
  _impl_.initial_transform_ = nullptr;
  return temp;
}
inline ::uesynth::Transform* SpawnObjectRequest::_internal_mutable_initial_transform() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.initial_transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::uesynth::Transform>(GetArenaForAllocation());
    _impl_.initial_transform_ = p;
  }
  return _impl_.initial_transform_;
}
inline ::uesynth::Transform* SpawnObjectRequest::mutable_initial_transform() {
  ::uesynth::Transform* _msg = _internal_mutable_initial_transform();
  // @@protoc_insertion_point(field_mutable:uesynth.SpawnObjectRequest.initial_transform)
  return _msg;
}
inline void SpawnObjectRequest::set_allocated_initial_transform(::uesynth::Transform* initial_transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.initial_transform_;
  }
  if (initial_transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(initial_transform);
    if (message_arena != submessage_arena) {
      initial_transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial_transform, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.initial_transform_ = initial_transform;
  // @@protoc_insertion_point(field_set_allocated:uesynth.SpawnObjectRequest.initial_transform)
}

// -------------------------------------------------------------------

// DestroyObjectRequest

// string object_name = 1;
inline void DestroyObjectRequest::clear_object_name() {
  _impl_.object_name_.ClearToEmpty();
}
inline const std::string& DestroyObjectRequest::object_name() const {
  // @@protoc_insertion_point(field_get:uesynth.DestroyObjectRequest.object_name)
  return _internal_object_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DestroyObjectRequest::set_object_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.object_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.DestroyObjectRequest.object_name)
}
inline std::string* DestroyObjectRequest::mutable_object_name() {
  std::string* _s = _internal_mutable_object_name();
  // @@protoc_insertion_point(field_mutable:uesynth.DestroyObjectRequest.object_name)
  return _s;
}
inline const std::string& DestroyObjectRequest::_internal_object_name() const {
  return _impl_.object_name_.Get();
}
inline void DestroyObjectRequest::_internal_set_object_name(const std::string& value) {
  ;


  _impl_.object_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DestroyObjectRequest::_internal_mutable_object_name() {
  ;
  return _impl_.object_name_.Mutable( GetArenaForAllocation());
}
inline std::string* DestroyObjectRequest::release_object_name() {
  // @@protoc_insertion_point(field_release:uesynth.DestroyObjectRequest.object_name)
  return _impl_.object_name_.Release();
}
inline void DestroyObjectRequest::set_allocated_object_name(std::string* value) {
  _impl_.object_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.object_name_.IsDefault()) {
          _impl_.object_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.DestroyObjectRequest.object_name)
}

// -------------------------------------------------------------------

// SetMaterialRequest

// string object_name = 1;
inline void SetMaterialRequest::clear_object_name() {
  _impl_.object_name_.ClearToEmpty();
}
inline const std::string& SetMaterialRequest::object_name() const {
  // @@protoc_insertion_point(field_get:uesynth.SetMaterialRequest.object_name)
  return _internal_object_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetMaterialRequest::set_object_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.object_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.SetMaterialRequest.object_name)
}
inline std::string* SetMaterialRequest::mutable_object_name() {
  std::string* _s = _internal_mutable_object_name();
  // @@protoc_insertion_point(field_mutable:uesynth.SetMaterialRequest.object_name)
  return _s;
}
inline const std::string& SetMaterialRequest::_internal_object_name() const {
  return _impl_.object_name_.Get();
}
inline void SetMaterialRequest::_internal_set_object_name(const std::string& value) {
  ;


  _impl_.object_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SetMaterialRequest::_internal_mutable_object_name() {
  ;
  return _impl_.object_name_.Mutable( GetArenaForAllocation());
}
inline std::string* SetMaterialRequest::release_object_name() {
  // @@protoc_insertion_point(field_release:uesynth.SetMaterialRequest.object_name)
  return _impl_.object_name_.Release();
}
inline void SetMaterialRequest::set_allocated_object_name(std::string* value) {
  _impl_.object_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.object_name_.IsDefault()) {
          _impl_.object_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.SetMaterialRequest.object_name)
}

// string material_property = 2;
inline void SetMaterialRequest::clear_material_property() {
  _impl_.material_property_.ClearToEmpty();
}
inline const std::string& SetMaterialRequest::material_property() const {
  // @@protoc_insertion_point(field_get:uesynth.SetMaterialRequest.material_property)
  return _internal_material_property();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetMaterialRequest::set_material_property(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.material_property_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.SetMaterialRequest.material_property)
}
inline std::string* SetMaterialRequest::mutable_material_property() {
  std::string* _s = _internal_mutable_material_property();
  // @@protoc_insertion_point(field_mutable:uesynth.SetMaterialRequest.material_property)
  return _s;
}
inline const std::string& SetMaterialRequest::_internal_material_property() const {
  return _impl_.material_property_.Get();
}
inline void SetMaterialRequest::_internal_set_material_property(const std::string& value) {
  ;


  _impl_.material_property_.Set(value, GetArenaForAllocation());
}
inline std::string* SetMaterialRequest::_internal_mutable_material_property() {
  ;
  return _impl_.material_property_.Mutable( GetArenaForAllocation());
}
inline std::string* SetMaterialRequest::release_material_property() {
  // @@protoc_insertion_point(field_release:uesynth.SetMaterialRequest.material_property)
  return _impl_.material_property_.Release();
}
inline void SetMaterialRequest::set_allocated_material_property(std::string* value) {
  _impl_.material_property_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.material_property_.IsDefault()) {
          _impl_.material_property_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.SetMaterialRequest.material_property)
}

// string value = 3;
inline void SetMaterialRequest::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& SetMaterialRequest::value() const {
  // @@protoc_insertion_point(field_get:uesynth.SetMaterialRequest.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetMaterialRequest::set_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.SetMaterialRequest.value)
}
inline std::string* SetMaterialRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:uesynth.SetMaterialRequest.value)
  return _s;
}
inline const std::string& SetMaterialRequest::_internal_value() const {
  return _impl_.value_.Get();
}
inline void SetMaterialRequest::_internal_set_value(const std::string& value) {
  ;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SetMaterialRequest::_internal_mutable_value() {
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* SetMaterialRequest::release_value() {
  // @@protoc_insertion_point(field_release:uesynth.SetMaterialRequest.value)
  return _impl_.value_.Release();
}
inline void SetMaterialRequest::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.SetMaterialRequest.value)
}

// -------------------------------------------------------------------

// SetLightingRequest

// string light_name = 1;
inline void SetLightingRequest::clear_light_name() {
  _impl_.light_name_.ClearToEmpty();
}
inline const std::string& SetLightingRequest::light_name() const {
  // @@protoc_insertion_point(field_get:uesynth.SetLightingRequest.light_name)
  return _internal_light_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetLightingRequest::set_light_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.light_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uesynth.SetLightingRequest.light_name)
}
inline std::string* SetLightingRequest::mutable_light_name() {
  std::string* _s = _internal_mutable_light_name();
  // @@protoc_insertion_point(field_mutable:uesynth.SetLightingRequest.light_name)
  return _s;
}
inline const std::string& SetLightingRequest::_internal_light_name() const {
  return _impl_.light_name_.Get();
}
inline void SetLightingRequest::_internal_set_light_name(const std::string& value) {
  ;


  _impl_.light_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SetLightingRequest::_internal_mutable_light_name() {
  ;
  return _impl_.light_name_.Mutable( GetArenaForAllocation());
}
inline std::string* SetLightingRequest::release_light_name() {
  // @@protoc_insertion_point(field_release:uesynth.SetLightingRequest.light_name)
  return _impl_.light_name_.Release();
}
inline void SetLightingRequest::set_allocated_light_name(std::string* value) {
  _impl_.light_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.light_name_.IsDefault()) {
          _impl_.light_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uesynth.SetLightingRequest.light_name)
}

// float intensity = 2;
inline void SetLightingRequest::clear_intensity() {
  _impl_.intensity_ = 0;
}
inline float SetLightingRequest::intensity() const {
  // @@protoc_insertion_point(field_get:uesynth.SetLightingRequest.intensity)
  return _internal_intensity();
}
inline void SetLightingRequest::set_intensity(float value) {
  _internal_set_intensity(value);
  // @@protoc_insertion_point(field_set:uesynth.SetLightingRequest.intensity)
}
inline float SetLightingRequest::_internal_intensity() const {
  return _impl_.intensity_;
}
inline void SetLightingRequest::_internal_set_intensity(float value) {
  ;
  _impl_.intensity_ = value;
}

// .uesynth.Vector3 color = 3;
inline bool SetLightingRequest::has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline void SetLightingRequest::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::uesynth::Vector3& SetLightingRequest::_internal_color() const {
  const ::uesynth::Vector3* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::uesynth::Vector3&>(
      ::uesynth::_Vector3_default_instance_);
}
inline const ::uesynth::Vector3& SetLightingRequest::color() const {
  // @@protoc_insertion_point(field_get:uesynth.SetLightingRequest.color)
  return _internal_color();
}
inline void SetLightingRequest::unsafe_arena_set_allocated_color(
    ::uesynth::Vector3* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.SetLightingRequest.color)
}
inline ::uesynth::Vector3* SetLightingRequest::release_color() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uesynth::Vector3* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uesynth::Vector3* SetLightingRequest::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:uesynth.SetLightingRequest.color)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uesynth::Vector3* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::uesynth::Vector3* SetLightingRequest::_internal_mutable_color() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::uesynth::Vector3>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::uesynth::Vector3* SetLightingRequest::mutable_color() {
  ::uesynth::Vector3* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:uesynth.SetLightingRequest.color)
  return _msg;
}
inline void SetLightingRequest::set_allocated_color(::uesynth::Vector3* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:uesynth.SetLightingRequest.color)
}

// .uesynth.Transform transform = 4;
inline bool SetLightingRequest::has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline void SetLightingRequest::clear_transform() {
  if (_impl_.transform_ != nullptr) _impl_.transform_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::uesynth::Transform& SetLightingRequest::_internal_transform() const {
  const ::uesynth::Transform* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::uesynth::Transform&>(
      ::uesynth::_Transform_default_instance_);
}
inline const ::uesynth::Transform& SetLightingRequest::transform() const {
  // @@protoc_insertion_point(field_get:uesynth.SetLightingRequest.transform)
  return _internal_transform();
}
inline void SetLightingRequest::unsafe_arena_set_allocated_transform(
    ::uesynth::Transform* transform) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = transform;
  if (transform) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uesynth.SetLightingRequest.transform)
}
inline ::uesynth::Transform* SetLightingRequest::release_transform() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::uesynth::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uesynth::Transform* SetLightingRequest::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_release:uesynth.SetLightingRequest.transform)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::uesynth::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::uesynth::Transform* SetLightingRequest::_internal_mutable_transform() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::uesynth::Transform>(GetArenaForAllocation());
    _impl_.transform_ = p;
  }
  return _impl_.transform_;
}
inline ::uesynth::Transform* SetLightingRequest::mutable_transform() {
  ::uesynth::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:uesynth.SetLightingRequest.transform)
  return _msg;
}
inline void SetLightingRequest::set_allocated_transform(::uesynth::Transform* transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.transform_;
  }
  if (transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:uesynth.SetLightingRequest.transform)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace uesynth


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_uesynth_2eproto_2epb_2eh
